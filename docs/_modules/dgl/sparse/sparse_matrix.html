<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dgl.sparse.sparse_matrix &mdash; DGL 2.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=0bf289b5" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=9caaf7ed"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../_static/copybutton.js?v=ccdb6887"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            DGL
          </a>
              <div class="version">
                2.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Get Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html">Install and Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/blitz/index.html">A Blitz Introduction to DGL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced Materials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../stochastic_training/index.html">üÜï Stochastic Training of GNNs with GraphBolt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide_cn/index.html">Áî®Êà∑ÊåáÂçó„ÄêÂåÖÂê´ËøáÊó∂‰ø°ÊÅØ„Äë</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide_ko/index.html">ÏÇ¨Ïö©Ïûê Í∞ÄÏù¥Îìú[ÏãúÎåÄÏóê Îí§Ï≥êÏßÑ]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graphtransformer/index.html">üÜï Tutorial: Graph Transformer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/sparse/index.html">Tutorials: dgl.sparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/cpu/index.html">Training on CPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/multi/index.html">Training on Multiple GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/dist/index.html">Distributed training</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/models/index.html">Paper Study with DGL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.html">dgl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.data.html">dgl.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.dataloading.html">dgl.dataloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.DGLGraph.html">dgl.DGLGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.distributed.html">dgl.distributed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.function.html">dgl.function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.geometry.html">dgl.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.graphbolt.html">üÜï dgl.graphbolt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/nn-pytorch.html">dgl.nn (PyTorch)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/nn.functional.html">dgl.nn.functional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.ops.html">dgl.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.optim.html">dgl.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.sampling.html">dgl.sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.sparse_v0.html">dgl.sparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.multiprocessing.html">dgl.multiprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/transforms.html">dgl.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/udf.html">User-defined Functions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contribute to DGL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/ffi.html">DGL Foreign Function Interface (FFI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../performance.html">Performance Benchmarks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Misc</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">Frequently Asked Questions (FAQ)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../env_var.html">Environment Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resources.html">Resources</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">DGL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">dgl.sparse.sparse_matrix</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dgl.sparse.sparse_matrix</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;DGL sparse matrix module.&quot;&quot;&quot;</span>
<span class="c1"># pylint: disable= invalid-name</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">torch</span>


<div class="viewcode-block" id="SparseMatrix">
<a class="viewcode-back" href="../../../api/python/dgl.sparse_v0.html#dgl.sparse.SparseMatrix">[docs]</a>
<span class="k">class</span> <span class="nc">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Class for sparse matrix.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c_sparse_matrix</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">ScriptObject</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span> <span class="o">=</span> <span class="n">c_sparse_matrix</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_sparse_matrix_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">val</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the values of the non-zero elements.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Values of the non-zero elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">val</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the shape of the sparse matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[int]</span>
<span class="sd">            The shape of the sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of non-zero elements in the sparse matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of non-zero elements of the matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">nnz</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the data type of the sparse matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.dtype</span>
<span class="sd">            Data type of the sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">val</span><span class="p">()</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the device the sparse matrix is on.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.device</span>
<span class="sd">            The device the sparse matrix is on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">device</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">row</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the row indices of the non-zero elements.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Row indices of the non-zero elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coo</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">col</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the column indices of the non-zero elements.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Column indices of the non-zero elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coo</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="SparseMatrix.coo">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.coo.html#dgl.sparse.SparseMatrix.coo">[docs]</a>
    <span class="k">def</span> <span class="nf">coo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the coordinate list (COO) representation of the sparse</span>
<span class="sd">        matrix.</span>

<span class="sd">        See `COO in Wikipedia &lt;https://en.wikipedia.org/wiki/</span>
<span class="sd">        Sparse_matrix#Coordinate_list_(COO)&gt;`_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Row coordinate</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Column coordinate</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 2, 1], [2, 4, 3]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices)</span>
<span class="sd">        &gt;&gt;&gt; A.coo()</span>
<span class="sd">        (tensor([1, 2, 1]), tensor([2, 4, 3]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">coo</span><span class="p">()</span></div>


<div class="viewcode-block" id="SparseMatrix.indices">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.indices.html#dgl.sparse.SparseMatrix.indices">[docs]</a>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the coordinate list (COO) representation in one tensor with</span>
<span class="sd">        shape ``(2, nnz)``.</span>

<span class="sd">        See `COO in Wikipedia &lt;https://en.wikipedia.org/wiki/</span>
<span class="sd">        Sparse_matrix#Coordinate_list_(COO)&gt;`_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Stacked COO tensor with shape ``(2, nnz)``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 2, 1], [2, 4, 3]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices)</span>
<span class="sd">        &gt;&gt;&gt; A.indices()</span>
<span class="sd">        tensor([[1, 2, 1],</span>
<span class="sd">                [2, 4, 3]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span></div>


<div class="viewcode-block" id="SparseMatrix.csr">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.csr.html#dgl.sparse.SparseMatrix.csr">[docs]</a>
    <span class="k">def</span> <span class="nf">csr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the compressed sparse row (CSR) representation of the sparse</span>
<span class="sd">        matrix.</span>

<span class="sd">        See `CSR in Wikipedia &lt;https://en.wikipedia.org/wiki/</span>
<span class="sd">        Sparse_matrix#Compressed_sparse_row_(CSR, _CRS_or_Yale_format)&gt;`_.</span>

<span class="sd">        This function also returns value indices as an index tensor, indicating</span>
<span class="sd">        the order of the values of non-zero elements in the CSR representation.</span>
<span class="sd">        A ``None`` value indices array indicates the order of the values stays</span>
<span class="sd">        the same as the values of the SparseMatrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Row indptr</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Column indices</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Value indices</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 2, 1], [2, 4, 3]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices)</span>
<span class="sd">        &gt;&gt;&gt; A.csr()</span>
<span class="sd">        (tensor([0, 0, 2, 3]), tensor([2, 3, 4]), tensor([0, 2, 1]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">csr</span><span class="p">()</span></div>


<div class="viewcode-block" id="SparseMatrix.csc">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.csc.html#dgl.sparse.SparseMatrix.csc">[docs]</a>
    <span class="k">def</span> <span class="nf">csc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the compressed sparse column (CSC) representation of the</span>
<span class="sd">        sparse matrix.</span>

<span class="sd">        See `CSC in Wikipedia &lt;https://en.wikipedia.org/wiki/</span>
<span class="sd">        Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS)&gt;`_.</span>

<span class="sd">        This function also returns value indices as an index tensor, indicating</span>
<span class="sd">        the order of the values of non-zero elements in the CSC representation.</span>
<span class="sd">        A ``None`` value indices array indicates the order of the values stays</span>
<span class="sd">        the same as the values of the SparseMatrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Column indptr</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Row indices</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Value indices</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 2, 1], [2, 4, 3]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices)</span>
<span class="sd">        &gt;&gt;&gt; A.csc()</span>
<span class="sd">        (tensor([0, 0, 0, 1, 2, 3]), tensor([1, 1, 2]), tensor([0, 2, 1]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">csc</span><span class="p">()</span></div>


<div class="viewcode-block" id="SparseMatrix.to_dense">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.to_dense.html#dgl.sparse.SparseMatrix.to_dense">[docs]</a>
    <span class="k">def</span> <span class="nf">to_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a copy in dense matrix format of the sparse matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            The copy in dense matrix format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coo</span><span class="p">()</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">mat</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">mat</span></div>


<div class="viewcode-block" id="SparseMatrix.t">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.t.html#dgl.sparse.SparseMatrix.t">[docs]</a>
    <span class="k">def</span> <span class="nf">t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias of :meth:`transpose()`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pylint: disable=C0103</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias of :meth:`transpose()`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

<div class="viewcode-block" id="SparseMatrix.transpose">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.transpose.html#dgl.sparse.SparseMatrix.transpose">[docs]</a>
    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the transpose of this sparse matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The transpose of this sparse matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 3], [2, 1, 3]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.tensor([1, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">        &gt;&gt;&gt; A = A.transpose()</span>
<span class="sd">        SparseMatrix(indices=tensor([[2, 1, 3],</span>
<span class="sd">                                     [1, 1, 3]]),</span>
<span class="sd">                     values=tensor([1, 1, 2]),</span>
<span class="sd">                     shape=(4, 4), nnz=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span></div>


<div class="viewcode-block" id="SparseMatrix.to">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.to.html#dgl.sparse.SparseMatrix.to">[docs]</a>
    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs matrix dtype and/or device conversion. If the target device</span>
<span class="sd">        and dtype are already in use, the original matrix will be returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        device : torch.device, optional</span>
<span class="sd">            The target device of the matrix if provided, otherwise the current</span>
<span class="sd">            device will be used</span>
<span class="sd">        dtype : torch.dtype, optional</span>
<span class="sd">            The target data type of the matrix values if provided, otherwise the</span>
<span class="sd">            current data type will be used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The converted matrix</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(3, 4))</span>
<span class="sd">        &gt;&gt;&gt; A.to(device=&quot;cuda:0&quot;, dtype=torch.int32)</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]], device=&#39;cuda:0&#39;),</span>
<span class="sd">                     values=tensor([1, 1, 1], device=&#39;cuda:0&#39;,</span>
<span class="sd">                                   dtype=torch.int32),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>

        <span class="k">if</span> <span class="n">device</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">device</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">val_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO(#5119): Find a better moving strategy instead of always</span>
            <span class="c1"># convert to COO format.</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coo</span><span class="p">()</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">from_coo</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.cuda">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.cuda.html#dgl.sparse.SparseMatrix.cuda">[docs]</a>
    <span class="k">def</span> <span class="nf">cuda</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Moves the matrix to GPU. If the matrix is already on GPU, the</span>
<span class="sd">        original matrix will be returned. If multiple GPU devices exist,</span>
<span class="sd">        ``cuda:0`` will be selected.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The matrix on GPU</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(3, 4))</span>
<span class="sd">        &gt;&gt;&gt; A.cuda()</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]], device=&#39;cuda:0&#39;),</span>
<span class="sd">                     values=tensor([1., 1., 1.], device=&#39;cuda:0&#39;),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.cpu">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.cpu.html#dgl.sparse.SparseMatrix.cpu">[docs]</a>
    <span class="k">def</span> <span class="nf">cpu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Moves the matrix to CPU. If the matrix is already on CPU, the</span>
<span class="sd">        original matrix will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The matrix on CPU</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]]).to(&quot;cuda&quot;)</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(3, 4))</span>

<span class="sd">        &gt;&gt;&gt; A.cpu()</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]]),</span>
<span class="sd">                     values=tensor([1., 1., 1.]),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.float">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.float.html#dgl.sparse.SparseMatrix.float">[docs]</a>
    <span class="k">def</span> <span class="nf">float</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts the matrix values to float32 data type. If the matrix</span>
<span class="sd">        already uses float data type, the original matrix will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The matrix with float values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.ones(len(row)).long()</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val, shape=(3, 4))</span>
<span class="sd">        &gt;&gt;&gt; A.float()</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]]),</span>
<span class="sd">                     values=tensor([1., 1., 1.]),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.double">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.double.html#dgl.sparse.SparseMatrix.double">[docs]</a>
    <span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts the matrix values to double data type. If the matrix already</span>
<span class="sd">        uses double data type, the original matrix will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The matrix with double values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(3, 4))</span>
<span class="sd">        &gt;&gt;&gt; A.double()</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]]),</span>
<span class="sd">                     values=tensor([1., 1., 1.], dtype=torch.float64),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.int">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.int.html#dgl.sparse.SparseMatrix.int">[docs]</a>
    <span class="k">def</span> <span class="nf">int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts the matrix values to int32 data type. If the matrix already</span>
<span class="sd">        uses int data type, the original matrix will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DiagMatrix</span>
<span class="sd">            The matrix with int values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(3, 4))</span>
<span class="sd">        &gt;&gt;&gt; A.int()</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]]),</span>
<span class="sd">                     values=tensor([1, 1, 1], dtype=torch.int32),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.long">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.long.html#dgl.sparse.SparseMatrix.long">[docs]</a>
    <span class="k">def</span> <span class="nf">long</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts the matrix values to long data type. If the matrix already</span>
<span class="sd">        uses long data type, the original matrix will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DiagMatrix</span>
<span class="sd">            The matrix with long values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [1, 2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(3, 4))</span>
<span class="sd">        &gt;&gt;&gt; A.long()</span>
<span class="sd">        SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                     [1, 2, 0]]),</span>
<span class="sd">                     values=tensor([1, 1, 1]),</span>
<span class="sd">                     shape=(3, 4), nnz=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseMatrix.coalesce">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.coalesce.html#dgl.sparse.SparseMatrix.coalesce">[docs]</a>
    <span class="k">def</span> <span class="nf">coalesce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a coalesced sparse matrix.</span>

<span class="sd">        A coalesced sparse matrix satisfies the following properties:</span>

<span class="sd">          - the indices of the non-zero elements are unique,</span>
<span class="sd">          - the indices are sorted in lexicographical order.</span>

<span class="sd">        The coalescing process will accumulate the non-zero elements of the same</span>
<span class="sd">        indices by summation.</span>

<span class="sd">        The function does not support autograd.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The coalesced sparse matrix</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 0, 0, 0, 1], [1, 1, 1, 2, 2]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.tensor([0, 1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">        &gt;&gt;&gt; A.coalesce()</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 0, 1, 1],</span>
<span class="sd">                                     [1, 2, 1, 2]]),</span>
<span class="sd">                     values=tensor([3, 3, 0, 4]),</span>
<span class="sd">                     shape=(2, 3), nnz=4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">coalesce</span><span class="p">())</span></div>


<div class="viewcode-block" id="SparseMatrix.has_duplicate">
<a class="viewcode-back" href="../../../generated/dgl.sparse.SparseMatrix.has_duplicate.html#dgl.sparse.SparseMatrix.has_duplicate">[docs]</a>
    <span class="k">def</span> <span class="nf">has_duplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns ``True`` if the sparse matrix contains duplicate indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[1, 0, 0, 0, 1], [1, 1, 1, 2, 2]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.tensor([0, 1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">        &gt;&gt;&gt; A.has_duplicate()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; A.coalesce().has_duplicate()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">has_duplicate</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">is_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns whether the sparse matrix is a diagonal matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">is_diag</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">index_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a sub-matrix selected according to the given index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            The dim to select from matrix, should be 0 or 1. `dim = 0` for</span>
<span class="sd">            rowwise selection and `dim = 1` for columnwise selection.</span>
<span class="sd">        index : torch.Tensor</span>
<span class="sd">            The selection index indicates which IDs from the `dim` should</span>
<span class="sd">            be chosen from the matrix.</span>
<span class="sd">            Note that duplicated ids are allowed.</span>

<span class="sd">        The function does not support autograd.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The sub-matrix which contains selected rows or columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([0, 1, 1, 2, 3, 4], [0, 2, 4, 3, 5, 0]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.tensor([0, 1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>

<span class="sd">        Case 1: Select rows by IDs.</span>

<span class="sd">        &gt;&gt;&gt; row_ids = torch.tensor([0, 1, 4])</span>
<span class="sd">        &gt;&gt;&gt; A.index_select(0, row_ids)</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 1, 1, 2],</span>
<span class="sd">                                     [0, 2, 4, 0]]),</span>
<span class="sd">                     values=tensor([0, 1, 2, 5]),</span>
<span class="sd">                     shape=(3, 6), nnz=4)</span>

<span class="sd">        Case 2: Select columns by IDs.</span>

<span class="sd">        &gt;&gt;&gt; column_ids = torch.tensor([0, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; A.index_select(1, column_ids)</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 4, 1, 3],</span>
<span class="sd">                                     [0, 0, 1, 2]]),</span>
<span class="sd">                     values=tensor([0, 5, 2, 4]),</span>
<span class="sd">                     shape=(5, 3), nnz=4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The selection dimension should be 0 or 1.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is unsupported input type.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">range_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">slice</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a sub-matrix selected according to the given range index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            The dim to select from matrix, should be 0 or 1. `dim = 0` for</span>
<span class="sd">            rowwise selection and `dim = 1` for columnwise selection.</span>
<span class="sd">        index : slice</span>
<span class="sd">            The selection slice indicates ID index from the `dim` should</span>
<span class="sd">            be chosen from the matrix.</span>

<span class="sd">        The function does not support autograd.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            The sub-matrix which contains selected rows or columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([0, 1, 1, 2, 3, 4], [0, 2, 4, 3, 5, 0]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.tensor([0, 1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>

<span class="sd">        Case 1: Select rows with given slice object.</span>

<span class="sd">        &gt;&gt;&gt; A.range_select(0, slice(1, 3))</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 0, 1],</span>
<span class="sd">                                     [2, 4, 3]]),</span>
<span class="sd">                     values=tensor([1, 2, 3]),</span>
<span class="sd">                     shape=(2, 6), nnz=3)</span>

<span class="sd">        Case 2: Select columns with given slice object.</span>

<span class="sd">        &gt;&gt;&gt; A.range_select(1, slice(3, 6))</span>
<span class="sd">        SparseMatrix(indices=tensor([[2, 1, 3],</span>
<span class="sd">                                     [0, 1, 2]]),</span>
<span class="sd">                     values=tensor([3, 2, 4]),</span>
<span class="sd">                     shape=(5, 3), nnz=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The selection dimension should be 0 or 1.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Slice with step other than 1 are not supported yet.&quot;</span>
                <span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span>
            <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">range_select</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is unsupported input type.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">fanout</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">replace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a sampled matrix on the given dimension and sample arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            The dimension for sampling, should be 0 or 1. `dim = 0` for</span>
<span class="sd">            rowwise selection and `dim = 1` for columnwise selection.</span>
<span class="sd">        fanout : int</span>
<span class="sd">            The number of elements to randomly sample on each row or column.</span>
<span class="sd">        ids : torch.Tensor, optional</span>
<span class="sd">            An optional tensor containing row or column IDs from which to</span>
<span class="sd">            sample elements.</span>
<span class="sd">            NOTE: If `ids` is not provided (i.e., `ids = None`), the function</span>
<span class="sd">            will sample from all rows or columns.</span>
<span class="sd">        replace : bool, optional</span>
<span class="sd">            Indicates whether repeated sampling of the same element is allowed.</span>
<span class="sd">            When `replace = True`, repeated sampling is permitted; when</span>
<span class="sd">            `replace = False`, it is not allowed.</span>
<span class="sd">            NOTE: If `replace = False` and there are fewer elements than</span>
<span class="sd">            `fanout`, all non-zero elements will be sampled.</span>
<span class="sd">        bias : bool, optional</span>
<span class="sd">            A boolean flag indicating whether to enable biasing during sampling.</span>
<span class="sd">            When `bias = True`, the values of the sparse matrix will be used as</span>
<span class="sd">            bias weights.</span>

<span class="sd">        The function does not support autograd.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix</span>
<span class="sd">            A submatrix with the same shape as the original matrix, containing</span>
<span class="sd">            the randomly sampled non-zero elements.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[0, 0, 1, 1, 2, 2, 2],</span>
<span class="sd">                                    [0, 2, 0, 1, 0, 1, 2]])</span>
<span class="sd">        &gt;&gt;&gt; val = torch.tensor([0, 1, 2, 3, 4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>

<span class="sd">        Case 1: Sample rows with the given number and disable repeated sampling.</span>

<span class="sd">        &gt;&gt;&gt; row_ids = torch.tensor([0, 2])</span>
<span class="sd">        &gt;&gt;&gt; A.sample(0, 2, row_ids)</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 0, 1, 1],</span>
<span class="sd">                                     [0, 2, 0, 2]]),</span>
<span class="sd">                     values=tensor([0, 1, 4, 6]),</span>
<span class="sd">                     shape=(2, 3), nnz=4)</span>

<span class="sd">        Case 2: Sample cols with the given number and disable repeated sampling.</span>

<span class="sd">        &gt;&gt;&gt; col_ids = torch.tensor([0, 2])</span>
<span class="sd">        &gt;&gt;&gt; A.sample(1, 2, col_ids)</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 1, 0, 2],</span>
<span class="sd">                                     [0, 0, 1, 1]]),</span>
<span class="sd">                     values=tensor([0, 2, 1, 6]),</span>
<span class="sd">                     shape=(3, 2), nnz=4)</span>

<span class="sd">        Case 3: Sample rows with the given number and enable repeated sampling.</span>

<span class="sd">        &gt;&gt;&gt; row_ids = torch.tensor([0, 1])</span>
<span class="sd">        &gt;&gt;&gt; A.sample(0, 2, row_ids, True)</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 0, 1, 1],</span>
<span class="sd">                                     [0, 2, 0, 0]]),</span>
<span class="sd">                     values=tensor([0, 1, 2, 2]),</span>
<span class="sd">                     shape=(2, 3), nnz=3)</span>

<span class="sd">        Case 4: Sample cols with the given number and enable repeated sampling.</span>

<span class="sd">        &gt;&gt;&gt; col_ids = torch.tensor([0, 1])</span>
<span class="sd">        &gt;&gt;&gt; A.sample(1, 2, col_ids, True)</span>
<span class="sd">        SparseMatrix(indices=tensor([[0, 1, 1, 1],</span>
<span class="sd">                                     [0, 0, 1, 1]]),</span>
<span class="sd">                     values=tensor([0, 2, 3, 3]),</span>
<span class="sd">                     shape=(3, 2), nnz=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">range</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="n">dim_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">fanout</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">replace</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">compact</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">leading_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compact sparse matrix by removing rows or columns without non-zero</span>
<span class="sd">        elements in the sparse matrix and relabeling indices of the dimension.</span>

<span class="sd">        This function serves a dual purpose: it allows you to reorganize the</span>
<span class="sd">        indices within a specific dimension (rows or columns) of the sparse</span>
<span class="sd">        matrix and, if needed, place certain &#39;leading_indices&#39; at the beginning</span>
<span class="sd">        of the relabeled dimension.</span>

<span class="sd">        In the absence of &#39;leading_indices&#39; (when it&#39;s set to `None`), the order</span>
<span class="sd">        of relabeled indices remains the same as the original order, except that</span>
<span class="sd">        rows or columns without non-zero elements are removed. When</span>
<span class="sd">        &#39;leading_indices&#39; are provided, they are positioned at the start of the</span>
<span class="sd">        relabeled dimension. To be precise, all rows selected by the specified</span>
<span class="sd">        indices will be remapped from 0 to length(indices) - 1. Rows that are not</span>
<span class="sd">        selected and contain any non-zero elements will be positioned after those</span>
<span class="sd">        remapped rows while maintaining their original order.</span>

<span class="sd">        This function mimics &#39;dgl.to_block&#39;, a method used to compress a sampled</span>
<span class="sd">        subgraph by eliminating redundant nodes. The &#39;leading_indices&#39; parameter</span>
<span class="sd">        replicates the behavior of &#39;include_dst_in_src&#39; in &#39;dgl.to_block&#39;,</span>
<span class="sd">        adding destination node information for message passing.</span>
<span class="sd">        Setting &#39;leading_indices&#39; to column IDs when relabeling the row</span>
<span class="sd">        dimension, for example, achieves the same effect as including destination</span>
<span class="sd">        nodes in source nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            The dimension to relabel. Should be 0 or 1. Use `dim = 0` for rowwise</span>
<span class="sd">            relabeling and `dim = 1` for columnwise relabeling.</span>
<span class="sd">        leading_indices : torch.Tensor, optional</span>
<span class="sd">            An optional tensor containing row or column ids that should be placed</span>
<span class="sd">            at the beginning of the relabeled dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[SparseMatrix, torch.Tensor]</span>
<span class="sd">            A tuple containing the relabeled sparse matrix and the index mapping</span>
<span class="sd">            of the relabeled dimension from the new index to the original index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; indices = torch.tensor([[0, 2],</span>
<span class="sd">                                    [1, 2]])</span>
<span class="sd">        &gt;&gt;&gt; A = dglsp.spmatrix(indices)</span>
<span class="sd">        &gt;&gt;&gt; print(A.to_dense())</span>
<span class="sd">        tensor([[0., 1., 0.],</span>
<span class="sd">                [0., 0., 0.],</span>
<span class="sd">                [0., 0., 1.]])</span>

<span class="sd">        Case 1: Compact rows without indices.</span>

<span class="sd">        &gt;&gt;&gt; B, original_rows = A.compact(dim=0, leading_indices=None)</span>
<span class="sd">        &gt;&gt;&gt; print(B.to_dense())</span>
<span class="sd">        tensor([[0., 1., 0.],</span>
<span class="sd">                [0., 0., 1.]])</span>
<span class="sd">        &gt;&gt;&gt; print(original_rows)</span>
<span class="sd">        torch.Tensor([0, 2])</span>

<span class="sd">        Case 2: Compact rows with indices.</span>

<span class="sd">        &gt;&gt;&gt; B, original_rows = A.compact(dim=0, leading_indices=[1, 2])</span>
<span class="sd">        &gt;&gt;&gt; print(B.to_dense())</span>
<span class="sd">        tensor([[0., 0., 0.],</span>
<span class="sd">                [0., 0., 1.],</span>
<span class="sd">                [0., 1., 0.],])</span>
<span class="sd">        &gt;&gt;&gt; print(original_rows)</span>
<span class="sd">        torch.Tensor([1, 2, 0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mat</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">dgl_sparse</span><span class="o">.</span><span class="n">compact</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">leading_indices</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span> <span class="n">idx</span></div>



<div class="viewcode-block" id="spmatrix">
<a class="viewcode-back" href="../../../generated/dgl.sparse.spmatrix.html#dgl.sparse.spmatrix">[docs]</a>
<span class="k">def</span> <span class="nf">spmatrix</span><span class="p">(</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Creates a sparse matrix from Coordinate format indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices : tensor.Tensor</span>
<span class="sd">        The indices are the coordinates of the non-zero elements in the matrix,</span>
<span class="sd">        which should have shape of ``(2, N)`` where the first row is the row</span>
<span class="sd">        indices and the second row is the column indices of non-zero elements.</span>
<span class="sd">    val : tensor.Tensor, optional</span>
<span class="sd">        The values of shape ``(nnz)`` or ``(nnz, D)``. If None, it will be a</span>
<span class="sd">        tensor of shape ``(nnz)`` filled by 1.</span>
<span class="sd">    shape : tuple[int, int], optional</span>
<span class="sd">        If not specified, it will be inferred from :attr:`row` and :attr:`col`,</span>
<span class="sd">        i.e., ``(row.max() + 1, col.max() + 1)``. Otherwise, :attr:`shape`</span>
<span class="sd">        should be no smaller than this.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Case1: Sparse matrix with row and column indices without values.</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.spmatrix(indices)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 5), nnz=3)</span>
<span class="sd">    &gt;&gt;&gt; # Specify shape</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.spmatrix(indices, shape=(5, 5))</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(5, 5), nnz=3)</span>

<span class="sd">    Case2: Sparse matrix with scalar values.</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.tensor([[1.], [2.], [3.]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([[1.],</span>
<span class="sd">                                [2.],</span>
<span class="sd">                                [3.]]),</span>
<span class="sd">                 shape=(3, 5), nnz=3, val_size=(1,))</span>

<span class="sd">    Case3: Sparse matrix with vector values.</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.tensor([[1., 1.], [2., 2.], [3., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([[1., 1.],</span>
<span class="sd">                                [2., 2.],</span>
<span class="sd">                                [3., 3.]]),</span>
<span class="sd">                 shape=(3, 5), nnz=3, val_size=(2,))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span>
    <span class="p">),</span> <span class="s2">&quot;The values of a SparseMatrix can only be scalars or vectors.&quot;</span>
    <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">dgl_sparse</span><span class="o">.</span><span class="n">from_coo</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span></div>



<div class="viewcode-block" id="from_coo">
<a class="viewcode-back" href="../../../generated/dgl.sparse.from_coo.html#dgl.sparse.from_coo">[docs]</a>
<span class="k">def</span> <span class="nf">from_coo</span><span class="p">(</span>
    <span class="n">row</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">col</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Creates a sparse matrix from a coordinate list (COO), which stores a list</span>
<span class="sd">    of (row, column, value) tuples.</span>

<span class="sd">    See `COO in Wikipedia</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_(COO)&gt;`_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    row : torch.Tensor</span>
<span class="sd">        The row indices of shape ``(nnz)``</span>
<span class="sd">    col : torch.Tensor</span>
<span class="sd">        The column indices of shape ``(nnz)``</span>
<span class="sd">    val : torch.Tensor, optional</span>
<span class="sd">        The values of shape ``(nnz)`` or ``(nnz, D)``. If None, it will be a</span>
<span class="sd">        tensor of shape ``(nnz)`` filled by 1.</span>
<span class="sd">    shape : tuple[int, int], optional</span>
<span class="sd">        If not specified, it will be inferred from :attr:`row` and :attr:`col`,</span>
<span class="sd">        i.e., ``(row.max() + 1, col.max() + 1)``. Otherwise, :attr:`shape`</span>
<span class="sd">        should be no smaller than this.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Case1: Sparse matrix with row and column indices without values.</span>

<span class="sd">    &gt;&gt;&gt; dst = torch.tensor([1, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; src = torch.tensor([2, 4, 3])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_coo(dst, src)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 5), nnz=3)</span>
<span class="sd">    &gt;&gt;&gt; # Specify shape</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_coo(dst, src, shape=(5, 5))</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(5, 5), nnz=3)</span>

<span class="sd">    Case2: Sparse matrix with scalar values.</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.tensor([[1.], [2.], [3.]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([[1.],</span>
<span class="sd">                                [2.],</span>
<span class="sd">                                [3.]]),</span>
<span class="sd">                 shape=(3, 5), nnz=3, val_size=(1,))</span>

<span class="sd">    Case3: Sparse matrix with vector values.</span>

<span class="sd">    &gt;&gt;&gt; dst = torch.tensor([1, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; src = torch.tensor([2, 4, 3])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.tensor([[1., 1.], [2., 2.], [3., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_coo(dst, src, val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([[1., 1.],</span>
<span class="sd">                                [2., 2.],</span>
<span class="sd">                                [3., 3.]]),</span>
<span class="sd">                 shape=(3, 5), nnz=3, val_size=(2,))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">row</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]),</span> <span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>



<div class="viewcode-block" id="from_csr">
<a class="viewcode-back" href="../../../generated/dgl.sparse.from_csr.html#dgl.sparse.from_csr">[docs]</a>
<span class="k">def</span> <span class="nf">from_csr</span><span class="p">(</span>
    <span class="n">indptr</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Creates a sparse matrix from compress sparse row (CSR) format.</span>

<span class="sd">    See `CSR in Wikipedia &lt;https://en.wikipedia.org/wiki/</span>
<span class="sd">    Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)&gt;`_.</span>

<span class="sd">    For row i of the sparse matrix</span>

<span class="sd">    - the column indices of the non-zero elements are stored in</span>
<span class="sd">      ``indices[indptr[i]: indptr[i+1]]``</span>
<span class="sd">    - the corresponding values are stored in ``val[indptr[i]: indptr[i+1]]``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indptr : torch.Tensor</span>
<span class="sd">        Pointer to the column indices of shape ``(N + 1)``, where ``N`` is the</span>
<span class="sd">        number of rows</span>
<span class="sd">    indices : torch.Tensor</span>
<span class="sd">        The column indices of shape ``(nnz)``</span>
<span class="sd">    val : torch.Tensor, optional</span>
<span class="sd">        The values of shape ``(nnz)`` or ``(nnz, D)``. If None, it will be a</span>
<span class="sd">        tensor of shape ``(nnz)`` filled by 1.</span>
<span class="sd">    shape : tuple[int, int], optional</span>
<span class="sd">        If not specified, it will be inferred from :attr:`indptr` and</span>
<span class="sd">        :attr:`indices`, i.e., ``(len(indptr) - 1, indices.max() + 1)``.</span>
<span class="sd">        Otherwise, :attr:`shape` should be no smaller than this.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Case1: Sparse matrix without values</span>

<span class="sd">    .. code::</span>

<span class="sd">        [[0, 1, 0],</span>
<span class="sd">         [0, 0, 1],</span>
<span class="sd">         [1, 1, 1]]</span>

<span class="sd">    &gt;&gt;&gt; indptr = torch.tensor([0, 1, 2, 5])</span>
<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([1, 2, 0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_csr(indptr, indices)</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2, 2, 2],</span>
<span class="sd">                                 [1, 2, 0, 1, 2]]),</span>
<span class="sd">                 values=tensor([1., 1., 1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 3), nnz=5)</span>
<span class="sd">    &gt;&gt;&gt; # Specify shape</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_csr(indptr, indices, shape=(3, 5))</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2, 2, 2],</span>
<span class="sd">                                 [1, 2, 0, 1, 2]]),</span>
<span class="sd">                 values=tensor([1., 1., 1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 5), nnz=5)</span>

<span class="sd">    Case2: Sparse matrix with scalar/vector values. Following example is with</span>
<span class="sd">    vector data.</span>

<span class="sd">    &gt;&gt;&gt; indptr = torch.tensor([0, 1, 2, 5])</span>
<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([1, 2, 0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.tensor([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_csr(indptr, indices, val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2, 2, 2],</span>
<span class="sd">                                 [1, 2, 0, 1, 2]]),</span>
<span class="sd">                 values=tensor([[1, 1],</span>
<span class="sd">                                [2, 2],</span>
<span class="sd">                                [3, 3],</span>
<span class="sd">                                [4, 4],</span>
<span class="sd">                                [5, 5]]),</span>
<span class="sd">                 shape=(3, 3), nnz=5, val_size=(2,))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">indptr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">indptr</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span>
    <span class="p">),</span> <span class="s2">&quot;The values of a SparseMatrix can only be scalars or vectors.&quot;</span>

    <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">dgl_sparse</span><span class="o">.</span><span class="n">from_csr</span><span class="p">(</span><span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="from_csc">
<a class="viewcode-back" href="../../../generated/dgl.sparse.from_csc.html#dgl.sparse.from_csc">[docs]</a>
<span class="k">def</span> <span class="nf">from_csc</span><span class="p">(</span>
    <span class="n">indptr</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Creates a sparse matrix from compress sparse column (CSC) format.</span>

<span class="sd">    See `CSC in Wikipedia &lt;https://en.wikipedia.org/wiki/</span>
<span class="sd">    Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS)&gt;`_.</span>

<span class="sd">    For column i of the sparse matrix</span>

<span class="sd">    - the row indices of the non-zero elements are stored in</span>
<span class="sd">      ``indices[indptr[i]: indptr[i+1]]``</span>
<span class="sd">    - the corresponding values are stored in ``val[indptr[i]: indptr[i+1]]``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indptr : torch.Tensor</span>
<span class="sd">        Pointer to the row indices of shape N + 1, where N is the</span>
<span class="sd">        number of columns</span>
<span class="sd">    indices : torch.Tensor</span>
<span class="sd">        The row indices of shape nnz</span>
<span class="sd">    val : torch.Tensor, optional</span>
<span class="sd">        The values of shape ``(nnz)`` or ``(nnz, D)``. If None, it will be a</span>
<span class="sd">        tensor of shape ``(nnz)`` filled by 1.</span>
<span class="sd">    shape : tuple[int, int], optional</span>
<span class="sd">        If not specified, it will be inferred from :attr:`indptr` and</span>
<span class="sd">        :attr:`indices`, i.e., ``(indices.max() + 1, len(indptr) - 1)``.</span>
<span class="sd">        Otherwise, :attr:`shape` should be no smaller than this.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Case1: Sparse matrix without values</span>

<span class="sd">    .. code::</span>

<span class="sd">        [[0, 1, 0],</span>
<span class="sd">         [0, 0, 1],</span>
<span class="sd">         [1, 1, 1]]</span>

<span class="sd">    &gt;&gt;&gt; indptr = torch.tensor([0, 1, 3, 5])</span>
<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([2, 0, 2, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_csc(indptr, indices)</span>
<span class="sd">    SparseMatrix(indices=tensor([[2, 0, 2, 1, 2],</span>
<span class="sd">                                 [0, 1, 1, 2, 2]]),</span>
<span class="sd">                 values=tensor([1., 1., 1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 3), nnz=5)</span>
<span class="sd">    &gt;&gt;&gt; # Specify shape</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_csc(indptr, indices, shape=(5, 3))</span>
<span class="sd">    SparseMatrix(indices=tensor([[2, 0, 2, 1, 2],</span>
<span class="sd">                                 [0, 1, 1, 2, 2]]),</span>
<span class="sd">                 values=tensor([1., 1., 1., 1., 1.]),</span>
<span class="sd">                 shape=(5, 3), nnz=5)</span>

<span class="sd">    Case2: Sparse matrix with scalar/vector values. Following example is with</span>
<span class="sd">    vector data.</span>

<span class="sd">    &gt;&gt;&gt; indptr = torch.tensor([0, 1, 3, 5])</span>
<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([2, 0, 2, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.tensor([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]])</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.from_csc(indptr, indices, val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[2, 0, 2, 1, 2],</span>
<span class="sd">                                 [0, 1, 1, 2, 2]]),</span>
<span class="sd">                 values=tensor([[1, 1],</span>
<span class="sd">                                [2, 2],</span>
<span class="sd">                                [3, 3],</span>
<span class="sd">                                [4, 4],</span>
<span class="sd">                                [5, 5]]),</span>
<span class="sd">                 shape=(3, 3), nnz=5, val_size=(2,))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">indptr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">indptr</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span>
    <span class="p">),</span> <span class="s2">&quot;The values of a SparseMatrix can only be scalars or vectors.&quot;</span>

    <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">dgl_sparse</span><span class="o">.</span><span class="n">from_csc</span><span class="p">(</span><span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="val_like">
<a class="viewcode-back" href="../../../generated/dgl.sparse.val_like.html#dgl.sparse.val_like">[docs]</a>
<span class="k">def</span> <span class="nf">val_like</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">SparseMatrix</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a sparse matrix from an existing sparse matrix using new values.</span>

<span class="sd">    The new sparse matrix will have the same non-zero indices as the given</span>
<span class="sd">    sparse matrix and use the given values as the new non-zero values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : SparseMatrix</span>
<span class="sd">        An existing sparse matrix with non-zero values</span>
<span class="sd">    val : torch.Tensor</span>
<span class="sd">        The new values of the non-zero elements, a tensor of shape ``(nnz)`` or</span>
<span class="sd">        ``(nnz, D)``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        New sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.ones(3)</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.spmatrix(indices, val)</span>
<span class="sd">    &gt;&gt;&gt; A = dglsp.val_like(A, torch.tensor([2, 2, 2]))</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([2, 2, 2]),</span>
<span class="sd">                 shape=(3, 5), nnz=3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span>
    <span class="p">),</span> <span class="s2">&quot;The values of a SparseMatrix can only be scalars or vectors.&quot;</span>

    <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">dgl_sparse</span><span class="o">.</span><span class="n">val_like</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">c_sparse_matrix</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span></div>



<div class="viewcode-block" id="diag">
<a class="viewcode-back" href="../../../generated/dgl.sparse.diag.html#dgl.sparse.diag">[docs]</a>
<span class="k">def</span> <span class="nf">diag</span><span class="p">(</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a sparse matrix based on the diagonal values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    val : torch.Tensor</span>
<span class="sd">        Diagonal of the matrix, in shape ``(N)`` or ``(N, D)``</span>
<span class="sd">    shape : tuple[int, int], optional</span>
<span class="sd">        If specified, :attr:`len(val)` must be equal to :attr:`min(shape)`,</span>
<span class="sd">        otherwise, it will be inferred from :attr:`val`, i.e., ``(N, N)``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Case1: 5-by-5 diagonal matrix with scaler values on the diagonal</span>

<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; val = torch.ones(5)</span>
<span class="sd">    &gt;&gt;&gt; dglsp.diag(val)</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2, 3, 4],</span>
<span class="sd">                                 [0, 1, 2, 3, 4]]),</span>
<span class="sd">                 values=tensor([1., 1., 1., 1., 1.]),</span>
<span class="sd">                 shape=(5, 5), nnz=5)</span>

<span class="sd">    Case2: 5-by-10 diagonal matrix with scaler values on the diagonal</span>

<span class="sd">    &gt;&gt;&gt; val = torch.ones(5)</span>
<span class="sd">    &gt;&gt;&gt; dglsp.diag(val, shape=(5, 10))</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2, 3, 4],</span>
<span class="sd">                                 [0, 1, 2, 3, 4]]),</span>
<span class="sd">                 values=tensor([1., 1., 1., 1., 1.]),</span>
<span class="sd">                 shape=(5, 10), nnz=5)</span>

<span class="sd">    Case3: 5-by-5 diagonal matrix with vector values on the diagonal</span>

<span class="sd">    &gt;&gt;&gt; val = torch.randn(5, 3)</span>
<span class="sd">    &gt;&gt;&gt; D = dglsp.diag(val)</span>
<span class="sd">    &gt;&gt;&gt; D.shape</span>
<span class="sd">    (5, 5)</span>
<span class="sd">    &gt;&gt;&gt; D.nnz</span>
<span class="sd">    5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span>
    <span class="p">),</span> <span class="s2">&quot;The values of a DiagMatrix can only be scalars or vectors.&quot;</span>
    <span class="n">len_val</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">len_val</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Expect len(val) to be min(shape) for a diagonal matrix, got&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">len_val</span><span class="si">}</span><span class="s2"> for len(val) and </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2"> for shape.&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">len_val</span><span class="p">,</span> <span class="n">len_val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">dgl_sparse</span><span class="o">.</span><span class="n">from_diag</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span></div>



<div class="viewcode-block" id="identity">
<a class="viewcode-back" href="../../../generated/dgl.sparse.identity.html#dgl.sparse.identity">[docs]</a>
<span class="k">def</span> <span class="nf">identity</span><span class="p">(</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">d</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Creates a sparse matrix with ones on the diagonal and zeros elsewhere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : tuple[int, int]</span>
<span class="sd">        Shape of the matrix.</span>
<span class="sd">    d : int, optional</span>
<span class="sd">        If None, the diagonal entries will be scaler 1. Otherwise, the diagonal</span>
<span class="sd">        entries will be a 1-valued tensor of shape ``(d)``.</span>
<span class="sd">    dtype : torch.dtype, optional</span>
<span class="sd">        The data type of the matrix</span>
<span class="sd">    device : torch.device, optional</span>
<span class="sd">        The device of the matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Case1: 3-by-3 matrix with scaler diagonal values</span>

<span class="sd">    .. code::</span>

<span class="sd">        [[1, 0, 0],</span>
<span class="sd">         [0, 1, 0],</span>
<span class="sd">         [0, 0, 1]]</span>

<span class="sd">    &gt;&gt;&gt; dglsp.identity(shape=(3, 3))</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2],</span>
<span class="sd">                                 [0, 1, 2]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 3), nnz=3)</span>

<span class="sd">    Case2: 3-by-5 matrix with scaler diagonal values</span>

<span class="sd">    .. code::</span>

<span class="sd">        [[1, 0, 0, 0, 0],</span>
<span class="sd">         [0, 1, 0, 0, 0],</span>
<span class="sd">         [0, 0, 1, 0, 0]]</span>

<span class="sd">    &gt;&gt;&gt; dglsp.identity(shape=(3, 5))</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2],</span>
<span class="sd">                                 [0, 1, 2]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 5), nnz=3)</span>

<span class="sd">    Case3: 3-by-3 matrix with vector diagonal values</span>

<span class="sd">    &gt;&gt;&gt; dglsp.identity(shape=(3, 3), d=2)</span>
<span class="sd">    SparseMatrix(indices=tensor([[0, 1, 2],</span>
<span class="sd">                                 [0, 1, 2]]),</span>
<span class="sd">                 values=tensor([[1., 1.],</span>
<span class="sd">                                [1., 1.],</span>
<span class="sd">                                [1., 1.]]),</span>
<span class="sd">                 shape=(3, 3), nnz=3, val_size=(2,))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">len_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">val_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">len_val</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">val_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">len_val</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">val_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">diag</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">from_torch_sparse</span><span class="p">(</span><span class="n">torch_sparse_tensor</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SparseMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a sparse matrix from a torch sparse tensor, which can have coo,</span>
<span class="sd">    csr, or csc layout.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    torch_sparse_tensor : torch.Tensor</span>
<span class="sd">        Torch sparse tensor</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.ones(3)</span>
<span class="sd">    &gt;&gt;&gt; torch_coo = torch.sparse_coo_tensor(indices, val)</span>
<span class="sd">    &gt;&gt;&gt; dglsp.from_torch_sparse(torch_coo)</span>
<span class="sd">    SparseMatrix(indices=tensor([[1, 1, 2],</span>
<span class="sd">                                 [2, 4, 3]]),</span>
<span class="sd">                 values=tensor([1., 1., 1.]),</span>
<span class="sd">                 shape=(3, 5), nnz=3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">layout</span> <span class="ow">in</span> <span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo</span><span class="p">,</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">sparse_csr</span><span class="p">,</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">sparse_csc</span><span class="p">,</span>
    <span class="p">),</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Cannot convert Pytorch sparse tensor with layout &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">layout</span><span class="si">}</span><span class="s2"> to DGL sparse.&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">layout</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo</span><span class="p">:</span>
        <span class="c1"># Use ._indices() and ._values() to access uncoalesced indices and</span>
        <span class="c1"># values.</span>
        <span class="k">return</span> <span class="n">spmatrix</span><span class="p">(</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">_indices</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">_values</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">layout</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_csr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">from_csr</span><span class="p">(</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">crow_indices</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">col_indices</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">from_csc</span><span class="p">(</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">ccol_indices</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">row_indices</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
            <span class="n">torch_sparse_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">to_torch_sparse_coo</span><span class="p">(</span><span class="n">spmat</span><span class="p">:</span> <span class="n">SparseMatrix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a torch sparse coo tensor from a sparse matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spmat : SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">        torch tensor with torch.sparse_coo layout</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 1, 2], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.ones(3)</span>
<span class="sd">    &gt;&gt;&gt; spmat = dglsp.spmatrix(indices, val)</span>
<span class="sd">    &gt;&gt;&gt; dglsp.to_torch_sparse_coo(spmat)</span>
<span class="sd">    tensor(indices=tensor([[1, 1, 2],</span>
<span class="sd">                           [2, 4, 3]]),</span>
<span class="sd">           values=tensor([1., 1., 1.]),</span>
<span class="sd">           size=(3, 5), nnz=3, layout=torch.sparse_coo)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">+=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">(</span><span class="n">spmat</span><span class="o">.</span><span class="n">indices</span><span class="p">(),</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">to_torch_sparse_csr</span><span class="p">(</span><span class="n">spmat</span><span class="p">:</span> <span class="n">SparseMatrix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a torch sparse csr tensor from a sparse matrix.</span>

<span class="sd">    Note that converting a sparse matrix to torch csr tensor could change the</span>
<span class="sd">    order of non-zero values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spmat : SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">        Torch tensor with torch.sparse_csr layout</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 2, 1], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.arange(3)</span>
<span class="sd">    &gt;&gt;&gt; spmat = dglsp.spmatrix(indices, val)</span>
<span class="sd">    &gt;&gt;&gt; dglsp.to_torch_sparse_csr(spmat)</span>
<span class="sd">    tensor(crow_indices=tensor([0, 0, 2, 3]),</span>
<span class="sd">           col_indices=tensor([2, 3, 4]),</span>
<span class="sd">           values=tensor([0, 2, 1]), size=(3, 5), nnz=3,</span>
<span class="sd">           layout=torch.sparse_csr)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">+=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">value_indices</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">csr</span><span class="p">()</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span>
    <span class="k">if</span> <span class="n">value_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">value_indices</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_csr_tensor</span><span class="p">(</span><span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">to_torch_sparse_csc</span><span class="p">(</span><span class="n">spmat</span><span class="p">:</span> <span class="n">SparseMatrix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a torch sparse csc tensor from a sparse matrix.</span>

<span class="sd">    Note that converting a sparse matrix to torch csc tensor could change the</span>
<span class="sd">    order of non-zero values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spmat : SparseMatrix</span>
<span class="sd">        Sparse matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">        Torch tensor with torch.sparse_csc layout</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; indices = torch.tensor([[1, 2, 1], [2, 4, 3]])</span>
<span class="sd">    &gt;&gt;&gt; val = torch.arange(3)</span>
<span class="sd">    &gt;&gt;&gt; spmat = dglsp.spmatrix(indices, val)</span>
<span class="sd">    &gt;&gt;&gt; dglsp.to_torch_sparse_csc(spmat)</span>
<span class="sd">    tensor(ccol_indices=tensor([0, 0, 0, 1, 2, 3]),</span>
<span class="sd">           row_indices=tensor([1, 1, 2]),</span>
<span class="sd">           values=tensor([0, 2, 1]), size=(3, 5), nnz=3,</span>
<span class="sd">           layout=torch.sparse_csc)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">+=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">value_indices</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">csc</span><span class="p">()</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span>
    <span class="k">if</span> <span class="n">value_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">value_indices</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_csc_tensor</span><span class="p">(</span><span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sparse_matrix_str</span><span class="p">(</span><span class="n">spmat</span><span class="p">:</span> <span class="n">SparseMatrix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal function for converting a sparse matrix to string</span>
<span class="sd">    representation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indices_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">spmat</span><span class="o">.</span><span class="n">coo</span><span class="p">()))</span>
    <span class="n">values_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    <span class="n">meta_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;shape=</span><span class="si">{</span><span class="n">spmat</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, nnz=</span><span class="si">{</span><span class="n">spmat</span><span class="o">.</span><span class="n">nnz</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">val_size</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">spmat</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">meta_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;, val_size=</span><span class="si">{</span><span class="n">val_size</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">spmat</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(&quot;</span>

    <span class="k">def</span> <span class="nf">_add_indent</span><span class="p">(</span><span class="n">_str</span><span class="p">,</span> <span class="n">indent</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="n">indent</span> <span class="o">+</span> <span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="n">final_str</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;indices=&quot;</span>
        <span class="o">+</span> <span class="n">_add_indent</span><span class="p">(</span><span class="n">indices_str</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;indices=&quot;</span><span class="p">))</span>
        <span class="o">+</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="o">+</span> <span class="s2">&quot;values=&quot;</span>
        <span class="o">+</span> <span class="n">_add_indent</span><span class="p">(</span><span class="n">values_str</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;values=&quot;</span><span class="p">))</span>
        <span class="o">+</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="o">+</span> <span class="n">meta_str</span>
        <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
    <span class="p">)</span>
    <span class="n">final_str</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">_add_indent</span><span class="p">(</span><span class="n">final_str</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">final_str</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, DGL Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>