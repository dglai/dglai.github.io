<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dgl.distributed.partition &mdash; DGL 2.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=0bf289b5" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=9caaf7ed"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../_static/copybutton.js?v=ccdb6887"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            DGL
          </a>
              <div class="version">
                2.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Get Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html">Install and Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/blitz/index.html">A Blitz Introduction to DGL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced Materials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../stochastic_training/index.html">🆕 Stochastic Training of GNNs with GraphBolt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide_cn/index.html">用户指南【包含过时信息】</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide_ko/index.html">사용자 가이드[시대에 뒤쳐진]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graphtransformer/index.html">🆕 Tutorial: Graph Transformer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/sparse/index.html">Tutorials: dgl.sparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/cpu/index.html">Training on CPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/multi/index.html">Training on Multiple GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/dist/index.html">Distributed training</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/models/index.html">Paper Study with DGL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.html">dgl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.data.html">dgl.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.dataloading.html">dgl.dataloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.DGLGraph.html">dgl.DGLGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.distributed.html">dgl.distributed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.function.html">dgl.function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.geometry.html">dgl.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.graphbolt.html">🆕 dgl.graphbolt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/nn-pytorch.html">dgl.nn (PyTorch)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/nn.functional.html">dgl.nn.functional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.ops.html">dgl.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.optim.html">dgl.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.sampling.html">dgl.sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.sparse_v0.html">dgl.sparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/dgl.multiprocessing.html">dgl.multiprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/transforms.html">dgl.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/udf.html">User-defined Functions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contribute to DGL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/ffi.html">DGL Foreign Function Interface (FFI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../performance.html">Performance Benchmarks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Misc</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">Frequently Asked Questions (FAQ)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../env_var.html">Environment Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resources.html">Resources</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">DGL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">dgl.distributed.partition</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dgl.distributed.partition</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Functions for partitions. &quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">torch</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">backend</span> <span class="k">as</span> <span class="n">F</span><span class="p">,</span> <span class="n">graphbolt</span> <span class="k">as</span> <span class="n">gb</span>
<span class="kn">from</span> <span class="nn">..base</span> <span class="kn">import</span> <span class="n">dgl_warning</span><span class="p">,</span> <span class="n">DGLError</span><span class="p">,</span> <span class="n">EID</span><span class="p">,</span> <span class="n">ETYPE</span><span class="p">,</span> <span class="n">NID</span><span class="p">,</span> <span class="n">NTYPE</span>
<span class="kn">from</span> <span class="nn">..convert</span> <span class="kn">import</span> <span class="n">heterograph</span><span class="p">,</span> <span class="n">to_homogeneous</span>
<span class="kn">from</span> <span class="nn">..data.utils</span> <span class="kn">import</span> <span class="n">load_graphs</span><span class="p">,</span> <span class="n">load_tensors</span><span class="p">,</span> <span class="n">save_graphs</span><span class="p">,</span> <span class="n">save_tensors</span>
<span class="kn">from</span> <span class="nn">..partition</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_peak_mem</span><span class="p">,</span>
    <span class="n">metis_partition_assignment</span><span class="p">,</span>
    <span class="n">partition_graph_with_halo</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..random</span> <span class="kn">import</span> <span class="n">choice</span> <span class="k">as</span> <span class="n">random_choice</span>
<span class="kn">from</span> <span class="nn">..transforms</span> <span class="kn">import</span> <span class="n">sort_csc_by_tag</span><span class="p">,</span> <span class="n">sort_csr_by_tag</span>
<span class="kn">from</span> <span class="nn">.constants</span> <span class="kn">import</span> <span class="n">DEFAULT_ETYPE</span><span class="p">,</span> <span class="n">DEFAULT_NTYPE</span><span class="p">,</span> <span class="n">DGL2GB_EID</span><span class="p">,</span> <span class="n">GB_DST_ID</span>
<span class="kn">from</span> <span class="nn">.graph_partition_book</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_etype_str_to_tuple</span><span class="p">,</span>
    <span class="n">_etype_tuple_to_str</span><span class="p">,</span>
    <span class="n">RangePartitionBook</span><span class="p">,</span>
<span class="p">)</span>


<span class="n">RESERVED_FIELD_DTYPE</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;inner_node&quot;</span><span class="p">:</span> <span class="p">(</span>
        <span class="n">F</span><span class="o">.</span><span class="n">uint8</span>
    <span class="p">),</span>  <span class="c1"># A flag indicates whether the node is inside a partition.</span>
    <span class="s2">&quot;inner_edge&quot;</span><span class="p">:</span> <span class="p">(</span>
        <span class="n">F</span><span class="o">.</span><span class="n">uint8</span>
    <span class="p">),</span>  <span class="c1"># A flag indicates whether the edge is inside a partition.</span>
    <span class="n">NID</span><span class="p">:</span> <span class="n">F</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
    <span class="n">EID</span><span class="p">:</span> <span class="n">F</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
    <span class="n">NTYPE</span><span class="p">:</span> <span class="n">F</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span>
    <span class="c1"># `sort_csr_by_tag` and `sort_csc_by_tag` works on int32/64 only.</span>
    <span class="n">ETYPE</span><span class="p">:</span> <span class="n">F</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_format_part_metadata</span><span class="p">(</span><span class="n">part_metadata</span><span class="p">,</span> <span class="n">formatter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Format etypes with specified formatter.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;edge_map&quot;</span><span class="p">,</span> <span class="s2">&quot;etypes&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">part_metadata</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">orig_data</span> <span class="o">=</span> <span class="n">part_metadata</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orig_data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">etype</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">orig_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">etype</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="n">etype</span><span class="p">)</span>
            <span class="n">new_data</span><span class="p">[</span><span class="n">etype</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">part_metadata</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data</span>
    <span class="k">return</span> <span class="n">part_metadata</span>


<span class="k">def</span> <span class="nf">_load_part_config</span><span class="p">(</span><span class="n">part_config</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load part config and format.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">part_config</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">part_metadata</span> <span class="o">=</span> <span class="n">_format_part_metadata</span><span class="p">(</span>
                <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">_etype_str_to_tuple</span>
            <span class="p">)</span>
    <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">DGLError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Failed to load partition config due to </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="s2">&quot;Probably caused by outdated config. If so, please refer to &quot;</span>
            <span class="s2">&quot;https://github.com/dmlc/dgl/tree/master/tools#change-edge-&quot;</span>
            <span class="s2">&quot;type-to-canonical-edge-type-for-partition-configuration-json&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">part_metadata</span>


<span class="k">def</span> <span class="nf">_dump_part_config</span><span class="p">(</span><span class="n">part_config</span><span class="p">,</span> <span class="n">part_metadata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Format and dump part config.&quot;&quot;&quot;</span>
    <span class="n">part_metadata</span> <span class="o">=</span> <span class="n">_format_part_metadata</span><span class="p">(</span><span class="n">part_metadata</span><span class="p">,</span> <span class="n">_etype_tuple_to_str</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">part_config</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
        <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">part_metadata</span><span class="p">,</span> <span class="n">outfile</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_save_graphs</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">g_list</span><span class="p">,</span> <span class="n">formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort_etypes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Preprocess partitions before saving:</span>
<span class="sd">    1. format data types.</span>
<span class="sd">    2. sort csc/csr by tag.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">g_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">RESERVED_FIELD_DTYPE</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">ndata</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edata</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">g_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sort_etypes</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">formats</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="s2">&quot;csr&quot;</span> <span class="ow">in</span> <span class="n">formats</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">sort_csr_by_tag</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">ETYPE</span><span class="p">],</span> <span class="n">tag_type</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;csc&quot;</span> <span class="ow">in</span> <span class="n">formats</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">sort_csc_by_tag</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">ETYPE</span><span class="p">],</span> <span class="n">tag_type</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>
    <span class="n">save_graphs</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">g_list</span><span class="p">,</span> <span class="n">formats</span><span class="o">=</span><span class="n">formats</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_inner_node_mask</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">ntype_id</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">NTYPE</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">ndata</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s2">&quot;inner_node&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s2">&quot;inner_node&quot;</span><span class="p">]</span>
            <span class="o">*</span> <span class="n">F</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NTYPE</span><span class="p">]</span> <span class="o">==</span> <span class="n">ntype_id</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="o">==</span> <span class="mi">1</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s2">&quot;inner_node&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">_get_inner_edge_mask</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">etype_id</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ETYPE</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edata</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="s2">&quot;inner_edge&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="s2">&quot;inner_edge&quot;</span><span class="p">]</span>
            <span class="o">*</span> <span class="n">F</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">ETYPE</span><span class="p">]</span> <span class="o">==</span> <span class="n">etype_id</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="o">==</span> <span class="mi">1</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="s2">&quot;inner_edge&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">_get_part_ranges</span><span class="p">(</span><span class="n">id_ranges</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">id_ranges</span><span class="p">:</span>
        <span class="c1"># Normally, each element has two values that represent the starting ID and the ending ID</span>
        <span class="c1"># of the ID range in a partition.</span>
        <span class="c1"># If not, the data is probably still in the old format, in which only the ending ID is</span>
        <span class="c1"># stored. We need to convert it to the format we expect.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">id_ranges</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">id_ranges</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                <span class="n">id_ranges</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">end</span>
        <span class="n">res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">id_ranges</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_verify_dgl_partition</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">part_id</span><span class="p">,</span> <span class="n">gpb</span><span class="p">,</span> <span class="n">ntypes</span><span class="p">,</span> <span class="n">etypes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verify the partition of a DGL graph.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">NID</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">ndata</span>
    <span class="p">),</span> <span class="s2">&quot;the partition graph should contain node mapping to global node ID&quot;</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">EID</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edata</span>
    <span class="p">),</span> <span class="s2">&quot;the partition graph should contain edge mapping to global edge ID&quot;</span>

    <span class="k">for</span> <span class="n">ntype</span> <span class="ow">in</span> <span class="n">ntypes</span><span class="p">:</span>
        <span class="n">ntype_id</span> <span class="o">=</span> <span class="n">ntypes</span><span class="p">[</span><span class="n">ntype</span><span class="p">]</span>
        <span class="c1"># graph.ndata[NID] are global homogeneous node IDs.</span>
        <span class="n">nids</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NID</span><span class="p">],</span> <span class="n">_get_inner_node_mask</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">ntype_id</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">partids1</span> <span class="o">=</span> <span class="n">gpb</span><span class="o">.</span><span class="n">nid2partid</span><span class="p">(</span><span class="n">nids</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">per_type_nids</span> <span class="o">=</span> <span class="n">gpb</span><span class="o">.</span><span class="n">map_to_per_ntype</span><span class="p">(</span><span class="n">nids</span><span class="p">)</span>
        <span class="n">partids2</span> <span class="o">=</span> <span class="n">gpb</span><span class="o">.</span><span class="n">nid2partid</span><span class="p">(</span><span class="n">per_type_nids</span><span class="p">,</span> <span class="n">ntype</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">partids1</span> <span class="o">==</span> <span class="n">part_id</span><span class="p">)),</span> <span class="p">(</span>
            <span class="s2">&quot;Unexpected partition IDs are found in the loaded partition &quot;</span>
            <span class="s2">&quot;while querying via global homogeneous node IDs.&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">partids2</span> <span class="o">==</span> <span class="n">part_id</span><span class="p">)),</span> <span class="p">(</span>
            <span class="s2">&quot;Unexpected partition IDs are found in the loaded partition &quot;</span>
            <span class="s2">&quot;while querying via type-wise node IDs.&quot;</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">etype</span> <span class="ow">in</span> <span class="n">etypes</span><span class="p">:</span>
        <span class="n">etype_id</span> <span class="o">=</span> <span class="n">etypes</span><span class="p">[</span><span class="n">etype</span><span class="p">]</span>
        <span class="c1"># graph.edata[EID] are global homogeneous edge IDs.</span>
        <span class="n">eids</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">EID</span><span class="p">],</span> <span class="n">_get_inner_edge_mask</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">etype_id</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">partids1</span> <span class="o">=</span> <span class="n">gpb</span><span class="o">.</span><span class="n">eid2partid</span><span class="p">(</span><span class="n">eids</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">per_type_eids</span> <span class="o">=</span> <span class="n">gpb</span><span class="o">.</span><span class="n">map_to_per_etype</span><span class="p">(</span><span class="n">eids</span><span class="p">)</span>
        <span class="n">partids2</span> <span class="o">=</span> <span class="n">gpb</span><span class="o">.</span><span class="n">eid2partid</span><span class="p">(</span><span class="n">per_type_eids</span><span class="p">,</span> <span class="n">etype</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">partids1</span> <span class="o">==</span> <span class="n">part_id</span><span class="p">)),</span> <span class="p">(</span>
            <span class="s2">&quot;Unexpected partition IDs are found in the loaded partition &quot;</span>
            <span class="s2">&quot;while querying via global homogeneous edge IDs.&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">partids2</span> <span class="o">==</span> <span class="n">part_id</span><span class="p">)),</span> <span class="p">(</span>
            <span class="s2">&quot;Unexpected partition IDs are found in the loaded partition &quot;</span>
            <span class="s2">&quot;while querying via type-wise edge IDs.&quot;</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">_verify_graphbolt_partition</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">part_id</span><span class="p">,</span> <span class="n">gpb</span><span class="p">,</span> <span class="n">ntypes</span><span class="p">,</span> <span class="n">etypes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verify the partition of a GraphBolt graph.&quot;&quot;&quot;</span>
    <span class="n">required_ndata_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">NID</span><span class="p">]</span>
    <span class="n">required_edata_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">EID</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="n">field</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">node_attributes</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">required_ndata_fields</span>
    <span class="p">),</span> <span class="s2">&quot;the partition graph should contain node mapping to global node ID.&quot;</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="n">field</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_attributes</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">required_edata_fields</span>
    <span class="p">),</span> <span class="s2">&quot;the partition graph should contain edge mapping to global edge ID.&quot;</span>

    <span class="n">num_edges</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">total_num_edges</span>
    <span class="n">local_src_ids</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">indices</span>
    <span class="n">local_dst_ids</span> <span class="o">=</span> <span class="n">gb</span><span class="o">.</span><span class="n">expand_indptr</span><span class="p">(</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">csc_indptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">local_src_ids</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="n">num_edges</span>
    <span class="p">)</span>
    <span class="n">global_src_ids</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">node_attributes</span><span class="p">[</span><span class="n">NID</span><span class="p">][</span><span class="n">local_src_ids</span><span class="p">]</span>
    <span class="n">global_dst_ids</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">node_attributes</span><span class="p">[</span><span class="n">NID</span><span class="p">][</span><span class="n">local_dst_ids</span><span class="p">]</span>

    <span class="n">etype_ids</span><span class="p">,</span> <span class="n">type_wise_eids</span> <span class="o">=</span> <span class="n">gpb</span><span class="o">.</span><span class="n">map_to_per_etype</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edge_attributes</span><span class="p">[</span><span class="n">EID</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">type_per_edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">etype_ids</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">type_per_edge</span><span class="p">)</span>
    <span class="n">etype_ids</span><span class="p">,</span> <span class="n">etype_ids_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">etype_ids</span><span class="p">)</span>
    <span class="n">global_src_ids</span> <span class="o">=</span> <span class="n">global_src_ids</span><span class="p">[</span><span class="n">etype_ids_indices</span><span class="p">]</span>
    <span class="n">global_dst_ids</span> <span class="o">=</span> <span class="n">global_dst_ids</span><span class="p">[</span><span class="n">etype_ids_indices</span><span class="p">]</span>
    <span class="n">type_wise_eids</span> <span class="o">=</span> <span class="n">type_wise_eids</span><span class="p">[</span><span class="n">etype_ids_indices</span><span class="p">]</span>

    <span class="n">src_ntype_ids</span><span class="p">,</span> <span class="n">src_type_wise_nids</span> <span class="o">=</span> <span class="n">gpb</span><span class="o">.</span><span class="n">map_to_per_ntype</span><span class="p">(</span><span class="n">global_src_ids</span><span class="p">)</span>
    <span class="n">dst_ntype_ids</span><span class="p">,</span> <span class="n">dst_type_wise_nids</span> <span class="o">=</span> <span class="n">gpb</span><span class="o">.</span><span class="n">map_to_per_ntype</span><span class="p">(</span><span class="n">global_dst_ids</span><span class="p">)</span>

    <span class="n">data_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">edge_ids</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c_etype</span><span class="p">,</span> <span class="n">etype_id</span> <span class="ow">in</span> <span class="n">etypes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">etype_ids</span> <span class="o">==</span> <span class="n">etype_id</span>
        <span class="n">src_ntype</span><span class="p">,</span> <span class="n">etype</span><span class="p">,</span> <span class="n">dst_ntype</span> <span class="o">=</span> <span class="n">c_etype</span>
        <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">actual_src_ntype_ids</span> <span class="o">=</span> <span class="n">src_ntype_ids</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">actual_dst_ntype_ids</span> <span class="o">=</span> <span class="n">dst_ntype_ids</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">expected_src_ntype_ids</span> <span class="o">=</span> <span class="n">ntypes</span><span class="p">[</span><span class="n">src_ntype</span><span class="p">]</span>
        <span class="n">expected_dst_ntype_ids</span> <span class="o">=</span> <span class="n">ntypes</span><span class="p">[</span><span class="n">dst_ntype</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">actual_src_ntype_ids</span> <span class="o">==</span> <span class="n">expected_src_ntype_ids</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected types of source nodes for </span><span class="si">{</span><span class="n">c_etype</span><span class="si">}</span><span class="s2">. Expected: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">expected_src_ntype_ids</span><span class="si">}</span><span class="s2">, but got: </span><span class="si">{</span><span class="n">actual_src_ntype_ids</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">actual_dst_ntype_ids</span> <span class="o">==</span> <span class="n">expected_dst_ntype_ids</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected types of destination nodes for </span><span class="si">{</span><span class="n">c_etype</span><span class="si">}</span><span class="s2">. Expected: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">expected_dst_ntype_ids</span><span class="si">}</span><span class="s2">, but got: </span><span class="si">{</span><span class="n">actual_dst_ntype_ids</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="n">c_etype</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">src_type_wise_nids</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dst_type_wise_nids</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">edge_ids</span><span class="p">[</span><span class="n">c_etype</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_wise_eids</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="c1"># Make sure node/edge IDs are not out of range.</span>
    <span class="n">hg</span> <span class="o">=</span> <span class="n">heterograph</span><span class="p">(</span>
        <span class="n">data_dict</span><span class="p">,</span> <span class="p">{</span><span class="n">ntype</span><span class="p">:</span> <span class="n">gpb</span><span class="o">.</span><span class="n">_num_nodes</span><span class="p">(</span><span class="n">ntype</span><span class="p">)</span> <span class="k">for</span> <span class="n">ntype</span> <span class="ow">in</span> <span class="n">ntypes</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">etype</span> <span class="ow">in</span> <span class="n">edge_ids</span><span class="p">:</span>
        <span class="n">hg</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">etype</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">EID</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_ids</span><span class="p">[</span><span class="n">etype</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="n">hg</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(</span><span class="n">etype</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">eids</span><span class="p">)</span> <span class="k">for</span> <span class="n">etype</span><span class="p">,</span> <span class="n">eids</span> <span class="ow">in</span> <span class="n">edge_ids</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">),</span> <span class="s2">&quot;The number of edges per etype in the partition graph is not correct.&quot;</span>
    <span class="k">assert</span> <span class="n">num_edges</span> <span class="o">==</span> <span class="n">hg</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(),</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;The total number of edges in the partition graph is not correct. &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;Expected: </span><span class="si">{</span><span class="n">num_edges</span><span class="si">}</span><span class="s2">, but got: </span><span class="si">{</span><span class="n">hg</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Partition </span><span class="si">{</span><span class="n">part_id</span><span class="si">}</span><span class="s2"> looks good!&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="load_partition">
<a class="viewcode-back" href="../../../generated/dgl.distributed.load_partition.html#dgl.distributed.load_partition">[docs]</a>
<span class="k">def</span> <span class="nf">load_partition</span><span class="p">(</span><span class="n">part_config</span><span class="p">,</span> <span class="n">part_id</span><span class="p">,</span> <span class="n">load_feats</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_graphbolt</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load data of a partition from the data path.</span>

<span class="sd">    A partition data includes a graph structure of the partition, a dict of node tensors,</span>
<span class="sd">    a dict of edge tensors and some metadata. The partition may contain the HALO nodes,</span>
<span class="sd">    which are the nodes replicated from other partitions. However, the dict of node tensors</span>
<span class="sd">    only contains the node data that belongs to the local partition. Similarly, edge tensors</span>
<span class="sd">    only contains the edge data that belongs to the local partition. The metadata include</span>
<span class="sd">    the information of the global graph (not the local partition), which includes the number</span>
<span class="sd">    of nodes, the number of edges as well as the node assignment of the global graph.</span>

<span class="sd">    The function currently loads data through the local filesystem interface.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    part_config : str</span>
<span class="sd">        The path of the partition config file.</span>
<span class="sd">    part_id : int</span>
<span class="sd">        The partition ID.</span>
<span class="sd">    load_feats : bool, optional</span>
<span class="sd">        Whether to load node/edge feats. If False, the returned node/edge feature</span>
<span class="sd">        dictionaries will be empty. Default: True.</span>
<span class="sd">    use_graphbolt : bool, optional</span>
<span class="sd">        Whether to load GraphBolt partition. Default: False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DGLGraph</span>
<span class="sd">        The graph partition structure.</span>
<span class="sd">    Dict[str, Tensor]</span>
<span class="sd">        Node features.</span>
<span class="sd">    Dict[(str, str, str), Tensor]</span>
<span class="sd">        Edge features.</span>
<span class="sd">    GraphPartitionBook</span>
<span class="sd">        The graph partition information.</span>
<span class="sd">    str</span>
<span class="sd">        The graph name</span>
<span class="sd">    List[str]</span>
<span class="sd">        The node types</span>
<span class="sd">    List[(str, str, str)]</span>
<span class="sd">        The edge types</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">config_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">part_config</span><span class="p">)</span>
    <span class="n">relative_to_config</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">path</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">config_path</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">part_config</span><span class="p">)</span> <span class="k">as</span> <span class="n">conf_f</span><span class="p">:</span>
        <span class="n">part_metadata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">conf_f</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="s2">&quot;part-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">part_id</span><span class="p">)</span> <span class="ow">in</span> <span class="n">part_metadata</span>
    <span class="p">),</span> <span class="s2">&quot;part-</span><span class="si">{}</span><span class="s2"> does not exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">part_id</span><span class="p">)</span>
    <span class="n">part_files</span> <span class="o">=</span> <span class="n">part_metadata</span><span class="p">[</span><span class="s2">&quot;part-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">part_id</span><span class="p">)]</span>
    <span class="n">part_graph_field</span> <span class="o">=</span> <span class="s2">&quot;part_graph&quot;</span>
    <span class="k">if</span> <span class="n">use_graphbolt</span><span class="p">:</span>
        <span class="n">part_graph_field</span> <span class="o">=</span> <span class="s2">&quot;part_graph_graphbolt&quot;</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">part_graph_field</span> <span class="ow">in</span> <span class="n">part_files</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;the partition does not contain graph structure: </span><span class="si">{</span><span class="n">part_graph_field</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">partition_path</span> <span class="o">=</span> <span class="n">relative_to_config</span><span class="p">(</span><span class="n">part_files</span><span class="p">[</span><span class="n">part_graph_field</span><span class="p">])</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Start to load partition from </span><span class="si">%s</span><span class="s2"> which is &quot;</span>
        <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bytes. It may take non-trivial &quot;</span>
        <span class="s2">&quot;time for large partition.&quot;</span><span class="p">,</span>
        <span class="n">partition_path</span><span class="p">,</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">partition_path</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">partition_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_graphbolt</span>
        <span class="k">else</span> <span class="n">load_graphs</span><span class="p">(</span><span class="n">partition_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finished loading partition from </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">partition_path</span><span class="p">)</span>

    <span class="n">gpb</span><span class="p">,</span> <span class="n">graph_name</span><span class="p">,</span> <span class="n">ntypes</span><span class="p">,</span> <span class="n">etypes</span> <span class="o">=</span> <span class="n">load_partition_book</span><span class="p">(</span><span class="n">part_config</span><span class="p">,</span> <span class="n">part_id</span><span class="p">)</span>
    <span class="n">ntypes_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ntypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">etypes_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">etypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">if</span> <span class="s2">&quot;DGL_DIST_DEBUG&quot;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
        <span class="n">_verify_func</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_verify_graphbolt_partition</span>
            <span class="k">if</span> <span class="n">use_graphbolt</span>
            <span class="k">else</span> <span class="n">_verify_dgl_partition</span>
        <span class="p">)</span>
        <span class="n">_verify_func</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">part_id</span><span class="p">,</span> <span class="n">gpb</span><span class="p">,</span> <span class="n">ntypes</span><span class="p">,</span> <span class="n">etypes</span><span class="p">)</span>

    <span class="n">node_feats</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">edge_feats</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">load_feats</span><span class="p">:</span>
        <span class="n">node_feats</span><span class="p">,</span> <span class="n">edge_feats</span> <span class="o">=</span> <span class="n">load_partition_feats</span><span class="p">(</span><span class="n">part_config</span><span class="p">,</span> <span class="n">part_id</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">node_feats</span><span class="p">,</span>
        <span class="n">edge_feats</span><span class="p">,</span>
        <span class="n">gpb</span><span class="p">,</span>
        <span class="n">graph_name</span><span class="p">,</span>
        <span class="n">ntypes_list</span><span class="p">,</span>
        <span class="n">etypes_list</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="load_partition_feats">
<a class="viewcode-back" href="../../../generated/dgl.distributed.load_partition_feats.html#dgl.distributed.load_partition_feats">[docs]</a>
<span class="k">def</span> <span class="nf">load_partition_feats</span><span class="p">(</span>
    <span class="n">part_config</span><span class="p">,</span> <span class="n">part_id</span><span class="p">,</span> <span class="n">load_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">load_edges</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load node/edge feature data from a partition.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    part_config : str</span>
<span class="sd">        The path of the partition config file.</span>
<span class="sd">    part_id : int</span>
<span class="sd">        The partition ID.</span>
<span class="sd">    load_nodes : bool, optional</span>
<span class="sd">        Whether to load node features. If ``False``, ``None`` is returned.</span>
<span class="sd">    load_edges : bool, optional</span>
<span class="sd">        Whether to load edge features. If ``False``, ``None`` is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dict[str, Tensor] or None</span>
<span class="sd">        Node features.</span>
<span class="sd">    Dict[str, Tensor] or None</span>
<span class="sd">        Edge features.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">config_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">part_config</span><span class="p">)</span>
    <span class="n">relative_to_config</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">path</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">config_path</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">part_config</span><span class="p">)</span> <span class="k">as</span> <span class="n">conf_f</span><span class="p">:</span>
        <span class="n">part_metadata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">conf_f</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="s2">&quot;part-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">part_id</span><span class="p">)</span> <span class="ow">in</span> <span class="n">part_metadata</span>
    <span class="p">),</span> <span class="s2">&quot;part-</span><span class="si">{}</span><span class="s2"> does not exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">part_id</span><span class="p">)</span>
    <span class="n">part_files</span> <span class="o">=</span> <span class="n">part_metadata</span><span class="p">[</span><span class="s2">&quot;part-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">part_id</span><span class="p">)]</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="s2">&quot;node_feats&quot;</span> <span class="ow">in</span> <span class="n">part_files</span>
    <span class="p">),</span> <span class="s2">&quot;the partition does not contain node features.&quot;</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="s2">&quot;edge_feats&quot;</span> <span class="ow">in</span> <span class="n">part_files</span>
    <span class="p">),</span> <span class="s2">&quot;the partition does not contain edge feature.&quot;</span>
    <span class="n">node_feats</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">load_nodes</span><span class="p">:</span>
        <span class="n">feat_path</span> <span class="o">=</span> <span class="n">relative_to_config</span><span class="p">(</span><span class="n">part_files</span><span class="p">[</span><span class="s2">&quot;node_feats&quot;</span><span class="p">])</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Start to load node data from </span><span class="si">%s</span><span class="s2"> which is &quot;</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bytes.&quot;</span><span class="p">,</span>
            <span class="n">feat_path</span><span class="p">,</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">feat_path</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">node_feats</span> <span class="o">=</span> <span class="n">load_tensors</span><span class="p">(</span><span class="n">feat_path</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finished loading node data.&quot;</span><span class="p">)</span>
    <span class="n">edge_feats</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">load_edges</span><span class="p">:</span>
        <span class="n">feat_path</span> <span class="o">=</span> <span class="n">relative_to_config</span><span class="p">(</span><span class="n">part_files</span><span class="p">[</span><span class="s2">&quot;edge_feats&quot;</span><span class="p">])</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Start to load edge data from </span><span class="si">%s</span><span class="s2"> which is &quot;</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bytes.&quot;</span><span class="p">,</span>
            <span class="n">feat_path</span><span class="p">,</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">feat_path</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">edge_feats</span> <span class="o">=</span> <span class="n">load_tensors</span><span class="p">(</span><span class="n">feat_path</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finished loading edge data.&quot;</span><span class="p">)</span>
    <span class="c1"># In the old format, the feature name doesn&#39;t contain node/edge type.</span>
    <span class="c1"># For compatibility, let&#39;s add node/edge types to the feature names.</span>
    <span class="k">if</span> <span class="n">node_feats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_feats</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node_feats</span><span class="p">:</span>
            <span class="n">feat</span> <span class="o">=</span> <span class="n">node_feats</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">DEFAULT_NTYPE</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">name</span>
            <span class="n">new_feats</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">feat</span>
        <span class="n">node_feats</span> <span class="o">=</span> <span class="n">new_feats</span>
    <span class="k">if</span> <span class="n">edge_feats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_feats</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">edge_feats</span><span class="p">:</span>
            <span class="n">feat</span> <span class="o">=</span> <span class="n">edge_feats</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">_etype_tuple_to_str</span><span class="p">(</span><span class="n">DEFAULT_ETYPE</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">name</span>
            <span class="n">new_feats</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">feat</span>
        <span class="n">edge_feats</span> <span class="o">=</span> <span class="n">new_feats</span>

    <span class="k">return</span> <span class="n">node_feats</span><span class="p">,</span> <span class="n">edge_feats</span></div>



<div class="viewcode-block" id="load_partition_book">
<a class="viewcode-back" href="../../../generated/dgl.distributed.load_partition_book.html#dgl.distributed.load_partition_book">[docs]</a>
<span class="k">def</span> <span class="nf">load_partition_book</span><span class="p">(</span><span class="n">part_config</span><span class="p">,</span> <span class="n">part_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load a graph partition book from the partition config file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    part_config : str</span>
<span class="sd">        The path of the partition config file.</span>
<span class="sd">    part_id : int</span>
<span class="sd">        The partition ID.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    GraphPartitionBook</span>
<span class="sd">        The global partition information.</span>
<span class="sd">    str</span>
<span class="sd">        The graph name</span>
<span class="sd">    dict</span>
<span class="sd">        The node types</span>
<span class="sd">    dict</span>
<span class="sd">        The edge types</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">part_metadata</span> <span class="o">=</span> <span class="n">_load_part_config</span><span class="p">(</span><span class="n">part_config</span><span class="p">)</span>
    <span class="k">assert</span> <span class="s2">&quot;num_parts&quot;</span> <span class="ow">in</span> <span class="n">part_metadata</span><span class="p">,</span> <span class="s2">&quot;num_parts does not exist.&quot;</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">part_metadata</span><span class="p">[</span><span class="s2">&quot;num_parts&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">part_id</span>
    <span class="p">),</span> <span class="s2">&quot;part </span><span class="si">{}</span><span class="s2"> is out of range (#parts: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">part_id</span><span class="p">,</span> <span class="n">part_metadata</span><span class="p">[</span><span class="s2">&quot;num_parts&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">num_parts</span> <span class="o">=</span> <span class="n">part_metadata</span><span class="p">[</span><span class="s2">&quot;num_parts&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="s2">&quot;num_nodes&quot;</span> <span class="ow">in</span> <span class="n">part_metadata</span>
    <span class="p">),</span> <span class="s2">&quot;cannot get the number of nodes of the global graph.&quot;</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="s2">&quot;num_edges&quot;</span> <span class="ow">in</span> <span class="n">part_metadata</span>
    <span class="p">),</span> <span class="s2">&quot;cannot get the number of edges of the global graph.&quot;</span>
    <span class="k">assert</span> <span class="s2">&quot;node_map&quot;</span> <span class="ow">in</span> <span class="n">part_metadata</span><span class="p">,</span> <span class="s2">&quot;cannot get the node map.&quot;</span>
    <span class="k">assert</span> <span class="s2">&quot;edge_map&quot;</span> <span class="ow">in</span> <span class="n">part_metadata</span><span class="p">,</span> <span class="s2">&quot;cannot get the edge map.&quot;</span>
    <span class="k">assert</span> <span class="s2">&quot;graph_name&quot;</span> <span class="ow">in</span> <span class="n">part_metadata</span><span class="p">,</span> <span class="s2">&quot;cannot get the graph name&quot;</span>

    <span class="c1"># If this is a range partitioning, node_map actually stores a list, whose elements</span>
    <span class="c1"># indicate the boundary of range partitioning. Otherwise, node_map stores a filename</span>
    <span class="c1"># that contains node map in a NumPy array.</span>
    <span class="n">node_map</span> <span class="o">=</span> <span class="n">part_metadata</span><span class="p">[</span><span class="s2">&quot;node_map&quot;</span><span class="p">]</span>
    <span class="n">edge_map</span> <span class="o">=</span> <span class="n">part_metadata</span><span class="p">[</span><span class="s2">&quot;edge_map&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">node_map</span><span class="p">:</span>
            <span class="n">is_range_part</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_map</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span>
            <span class="k">break</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_map</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">is_range_part</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">node_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">DEFAULT_NTYPE</span><span class="p">:</span> <span class="n">node_map</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">is_range_part</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_map</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">edge_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">DEFAULT_ETYPE</span><span class="p">:</span> <span class="n">edge_map</span><span class="p">}</span>

    <span class="n">ntypes</span> <span class="o">=</span> <span class="p">{</span><span class="n">DEFAULT_NTYPE</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">etypes</span> <span class="o">=</span> <span class="p">{</span><span class="n">DEFAULT_ETYPE</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="k">if</span> <span class="s2">&quot;ntypes&quot;</span> <span class="ow">in</span> <span class="n">part_metadata</span><span class="p">:</span>
        <span class="n">ntypes</span> <span class="o">=</span> <span class="n">part_metadata</span><span class="p">[</span><span class="s2">&quot;ntypes&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">&quot;etypes&quot;</span> <span class="ow">in</span> <span class="n">part_metadata</span><span class="p">:</span>
        <span class="n">etypes</span> <span class="o">=</span> <span class="n">part_metadata</span><span class="p">[</span><span class="s2">&quot;etypes&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">node_map</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ntypes</span><span class="p">,</span> <span class="s2">&quot;The node type </span><span class="si">{}</span><span class="s2"> is invalid&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">edge_map</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">etypes</span><span class="p">,</span> <span class="s2">&quot;The edge type </span><span class="si">{}</span><span class="s2"> is invalid&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_range_part</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only RangePartitionBook is supported currently.&quot;</span><span class="p">)</span>

    <span class="n">node_map</span> <span class="o">=</span> <span class="n">_get_part_ranges</span><span class="p">(</span><span class="n">node_map</span><span class="p">)</span>
    <span class="n">edge_map</span> <span class="o">=</span> <span class="n">_get_part_ranges</span><span class="p">(</span><span class="n">edge_map</span><span class="p">)</span>

    <span class="c1"># Format dtype of node/edge map if dtype is specified.</span>
    <span class="k">def</span> <span class="nf">_format_node_edge_map</span><span class="p">(</span><span class="n">part_metadata</span><span class="p">,</span> <span class="n">map_type</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">map_type</span><span class="si">}</span><span class="s2">_map_dtype&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">part_metadata</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">part_metadata</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;int32&quot;</span><span class="p">,</span> <span class="s2">&quot;int64&quot;</span><span class="p">],</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">map_type</span><span class="si">}</span><span class="s2"> map dtype should be either int32 or int64, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="n">node_map</span> <span class="o">=</span> <span class="n">_format_node_edge_map</span><span class="p">(</span><span class="n">part_metadata</span><span class="p">,</span> <span class="s2">&quot;node&quot;</span><span class="p">,</span> <span class="n">node_map</span><span class="p">)</span>
    <span class="n">edge_map</span> <span class="o">=</span> <span class="n">_format_node_edge_map</span><span class="p">(</span><span class="n">part_metadata</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="n">edge_map</span><span class="p">)</span>

    <span class="c1"># Sort the node/edge maps by the node/edge type ID.</span>
    <span class="n">node_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">node_map</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ntypes</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
    <span class="n">edge_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">edge_map</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">etypes</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

    <span class="k">def</span> <span class="nf">_assert_is_sorted</span><span class="p">(</span><span class="n">id_map</span><span class="p">):</span>
        <span class="n">id_ranges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">id_map</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_parts</span><span class="p">):</span>
            <span class="n">ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_ranges</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="n">ids</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The node/edge map is not sorted: </span><span class="si">{</span><span class="n">ids</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">_assert_is_sorted</span><span class="p">(</span><span class="n">node_map</span><span class="p">)</span>
    <span class="n">_assert_is_sorted</span><span class="p">(</span><span class="n">edge_map</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">RangePartitionBook</span><span class="p">(</span>
            <span class="n">part_id</span><span class="p">,</span> <span class="n">num_parts</span><span class="p">,</span> <span class="n">node_map</span><span class="p">,</span> <span class="n">edge_map</span><span class="p">,</span> <span class="n">ntypes</span><span class="p">,</span> <span class="n">etypes</span>
        <span class="p">),</span>
        <span class="n">part_metadata</span><span class="p">[</span><span class="s2">&quot;graph_name&quot;</span><span class="p">],</span>
        <span class="n">ntypes</span><span class="p">,</span>
        <span class="n">etypes</span><span class="p">,</span>
    <span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_get_orig_ids</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sim_g</span><span class="p">,</span> <span class="n">orig_nids</span><span class="p">,</span> <span class="n">orig_eids</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert/construct the original node IDs and edge IDs.</span>

<span class="sd">    It handles multiple cases:</span>
<span class="sd">     * If the graph has been reshuffled and it&#39;s a homogeneous graph, we just return</span>
<span class="sd">       the original node IDs and edge IDs in the inputs.</span>
<span class="sd">     * If the graph has been reshuffled and it&#39;s a heterogeneous graph, we need to</span>
<span class="sd">       split the original node IDs and edge IDs in the inputs based on the node types</span>
<span class="sd">       and edge types.</span>
<span class="sd">     * If the graph is not shuffled, the original node IDs and edge IDs don&#39;t change.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : DGLGraph</span>
<span class="sd">       The input graph for partitioning.</span>
<span class="sd">    sim_g : DGLGraph</span>
<span class="sd">        The homogeneous version of the input graph.</span>
<span class="sd">    orig_nids : tensor or None</span>
<span class="sd">        The original node IDs after the input graph is reshuffled.</span>
<span class="sd">    orig_eids : tensor or None</span>
<span class="sd">        The original edge IDs after the input graph is reshuffled.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor or dict of tensors, tensor or dict of tensors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_hetero</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_homogeneous</span>
    <span class="k">if</span> <span class="n">is_hetero</span><span class="p">:</span>
        <span class="c1"># Get the type IDs</span>
        <span class="n">orig_ntype</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span><span class="n">sim_g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NTYPE</span><span class="p">],</span> <span class="n">orig_nids</span><span class="p">)</span>
        <span class="n">orig_etype</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span><span class="n">sim_g</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">ETYPE</span><span class="p">],</span> <span class="n">orig_eids</span><span class="p">)</span>
        <span class="c1"># Mapping between shuffled global IDs to original per-type IDs</span>
        <span class="n">orig_nids</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span><span class="n">sim_g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NID</span><span class="p">],</span> <span class="n">orig_nids</span><span class="p">)</span>
        <span class="n">orig_eids</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span><span class="n">sim_g</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">EID</span><span class="p">],</span> <span class="n">orig_eids</span><span class="p">)</span>
        <span class="n">orig_nids</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">ntype</span><span class="p">:</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span>
                <span class="n">orig_nids</span><span class="p">,</span> <span class="n">orig_ntype</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">get_ntype_id</span><span class="p">(</span><span class="n">ntype</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">ntype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">ntypes</span>
        <span class="p">}</span>
        <span class="n">orig_eids</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">etype</span><span class="p">:</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span>
                <span class="n">orig_eids</span><span class="p">,</span> <span class="n">orig_etype</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">get_etype_id</span><span class="p">(</span><span class="n">etype</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">etype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">canonical_etypes</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="n">orig_nids</span><span class="p">,</span> <span class="n">orig_eids</span>


<span class="k">def</span> <span class="nf">_set_trainer_ids</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sim_g</span><span class="p">,</span> <span class="n">node_parts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set the trainer IDs for each node and edge on the input graph.</span>

<span class="sd">    The trainer IDs will be stored as node data and edge data in the input graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : DGLGraph</span>
<span class="sd">       The input graph for partitioning.</span>
<span class="sd">    sim_g : DGLGraph</span>
<span class="sd">        The homogeneous version of the input graph.</span>
<span class="sd">    node_parts : tensor</span>
<span class="sd">        The node partition ID for each node in `sim_g`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_homogeneous</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s2">&quot;trainer_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_parts</span>
        <span class="c1"># An edge is assigned to a partition based on its destination node.</span>
        <span class="n">g</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="s2">&quot;trainer_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span><span class="n">node_parts</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ntype_id</span><span class="p">,</span> <span class="n">ntype</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">ntypes</span><span class="p">):</span>
            <span class="n">type_idx</span> <span class="o">=</span> <span class="n">sim_g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NTYPE</span><span class="p">]</span> <span class="o">==</span> <span class="n">ntype_id</span>
            <span class="n">orig_nid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">sim_g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NID</span><span class="p">],</span> <span class="n">type_idx</span><span class="p">)</span>
            <span class="n">trainer_id</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">orig_nid</span><span class="p">),),</span> <span class="n">F</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">node_parts</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
            <span class="n">F</span><span class="o">.</span><span class="n">scatter_row_inplace</span><span class="p">(</span>
                <span class="n">trainer_id</span><span class="p">,</span> <span class="n">orig_nid</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">node_parts</span><span class="p">,</span> <span class="n">type_idx</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ntype</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;trainer_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trainer_id</span>
        <span class="k">for</span> <span class="n">c_etype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">canonical_etypes</span><span class="p">:</span>
            <span class="c1"># An edge is assigned to a partition based on its destination node.</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dst_type</span> <span class="o">=</span> <span class="n">c_etype</span>
            <span class="n">trainer_id</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span>
                <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">dst_type</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;trainer_id&quot;</span><span class="p">],</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">etype</span><span class="o">=</span><span class="n">c_etype</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">c_etype</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;trainer_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trainer_id</span>


<div class="viewcode-block" id="partition_graph">
<a class="viewcode-back" href="../../../generated/dgl.distributed.partition_graph.html#dgl.distributed.partition_graph">[docs]</a>
<span class="k">def</span> <span class="nf">partition_graph</span><span class="p">(</span>
    <span class="n">g</span><span class="p">,</span>
    <span class="n">graph_name</span><span class="p">,</span>
    <span class="n">num_parts</span><span class="p">,</span>
    <span class="n">out_path</span><span class="p">,</span>
    <span class="n">num_hops</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">part_method</span><span class="o">=</span><span class="s2">&quot;metis&quot;</span><span class="p">,</span>
    <span class="n">balance_ntypes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">balance_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_mapping</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">num_trainers_per_machine</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">objtype</span><span class="o">=</span><span class="s2">&quot;cut&quot;</span><span class="p">,</span>
    <span class="n">graph_formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">use_graphbolt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Partition a graph for distributed training and store the partitions on files.</span>

<span class="sd">    The partitioning occurs in three steps: 1) run a partition algorithm (e.g., Metis) to</span>
<span class="sd">    assign nodes to partitions; 2) construct partition graph structure based on</span>
<span class="sd">    the node assignment; 3) split the node features and edge features based on</span>
<span class="sd">    the partition result.</span>

<span class="sd">    When a graph is partitioned, each partition can contain *HALO* nodes, which are assigned</span>
<span class="sd">    to other partitions but are included in this partition for efficiency purpose.</span>
<span class="sd">    In this document, *local nodes/edges* refers to the nodes and edges that truly belong to</span>
<span class="sd">    a partition. The rest are &quot;HALO nodes/edges&quot;.</span>

<span class="sd">    The partitioned data is stored into multiple files organized as follows:</span>

<span class="sd">    .. code-block:: none</span>

<span class="sd">        data_root_dir/</span>
<span class="sd">          |-- graph_name.json     # partition configuration file in JSON</span>
<span class="sd">          |-- node_map.npy        # partition id of each node stored in a numpy array (optional)</span>
<span class="sd">          |-- edge_map.npy        # partition id of each edge stored in a numpy array (optional)</span>
<span class="sd">          |-- part0/              # data for partition 0</span>
<span class="sd">              |-- node_feats.dgl  # node features stored in binary format</span>
<span class="sd">              |-- edge_feats.dgl  # edge features stored in binary format</span>
<span class="sd">              |-- graph.dgl       # graph structure of this partition stored in binary format</span>
<span class="sd">          |-- part1/              # data for partition 1</span>
<span class="sd">              |-- node_feats.dgl</span>
<span class="sd">              |-- edge_feats.dgl</span>
<span class="sd">              |-- graph.dgl</span>

<span class="sd">    First, the metadata of the original graph and the partitioning is stored in a JSON file</span>
<span class="sd">    named after ``graph_name``. This JSON file contains the information of the original graph</span>
<span class="sd">    as well as the path of the files that store each partition. Below show an example.</span>

<span class="sd">    .. code-block:: none</span>

<span class="sd">        {</span>
<span class="sd">           &quot;graph_name&quot; : &quot;test&quot;,</span>
<span class="sd">           &quot;part_method&quot; : &quot;metis&quot;,</span>
<span class="sd">           &quot;num_parts&quot; : 2,</span>
<span class="sd">           &quot;halo_hops&quot; : 1,</span>
<span class="sd">           &quot;node_map&quot;: {</span>
<span class="sd">               &quot;_N&quot;: [ [ 0, 1261310 ],</span>
<span class="sd">                       [ 1261310, 2449029 ] ]</span>
<span class="sd">           },</span>
<span class="sd">           &quot;edge_map&quot;: {</span>
<span class="sd">               &quot;_N:_E:_N&quot;: [ [ 0, 62539528 ],</span>
<span class="sd">                             [ 62539528, 123718280 ] ]</span>
<span class="sd">           },</span>
<span class="sd">           &quot;etypes&quot;: { &quot;_N:_E:_N&quot;: 0 },</span>
<span class="sd">           &quot;ntypes&quot;: { &quot;_N&quot;: 0 },</span>
<span class="sd">           &quot;num_nodes&quot; : 1000000,</span>
<span class="sd">           &quot;num_edges&quot; : 52000000,</span>
<span class="sd">           &quot;part-0&quot; : {</span>
<span class="sd">             &quot;node_feats&quot; : &quot;data_root_dir/part0/node_feats.dgl&quot;,</span>
<span class="sd">             &quot;edge_feats&quot; : &quot;data_root_dir/part0/edge_feats.dgl&quot;,</span>
<span class="sd">             &quot;part_graph&quot; : &quot;data_root_dir/part0/graph.dgl&quot;,</span>
<span class="sd">           },</span>
<span class="sd">           &quot;part-1&quot; : {</span>
<span class="sd">             &quot;node_feats&quot; : &quot;data_root_dir/part1/node_feats.dgl&quot;,</span>
<span class="sd">             &quot;edge_feats&quot; : &quot;data_root_dir/part1/edge_feats.dgl&quot;,</span>
<span class="sd">             &quot;part_graph&quot; : &quot;data_root_dir/part1/graph.dgl&quot;,</span>
<span class="sd">           },</span>
<span class="sd">        }</span>

<span class="sd">    Here are the definition of the fields in the partition configuration file:</span>

<span class="sd">    * ``graph_name`` is the name of the graph given by a user.</span>
<span class="sd">    * ``part_method`` is the method used to assign nodes to partitions.</span>
<span class="sd">      Currently, it supports &quot;random&quot; and &quot;metis&quot;.</span>
<span class="sd">    * ``num_parts`` is the number of partitions.</span>
<span class="sd">    * ``halo_hops`` is the number of hops of nodes we include in a partition as HALO nodes.</span>
<span class="sd">    * ``node_map`` is the node assignment map, which tells the partition ID a node is assigned to.</span>
<span class="sd">      The format of ``node_map`` is described below.</span>
<span class="sd">    * ``edge_map`` is the edge assignment map, which tells the partition ID an edge is assigned to.</span>
<span class="sd">    * ``num_nodes`` is the number of nodes in the global graph.</span>
<span class="sd">    * ``num_edges`` is the number of edges in the global graph.</span>
<span class="sd">    * `part-*` stores the data of a partition.</span>

<span class="sd">    As node/edge IDs are reshuffled, ``node_map`` and ``edge_map`` contains the information</span>
<span class="sd">    for mapping between global node/edge IDs to partition-local node/edge IDs.</span>
<span class="sd">    For heterogeneous graphs, the information in ``node_map`` and ``edge_map`` can also be used</span>
<span class="sd">    to compute node types and edge types. The format of the data in ``node_map`` and ``edge_map``</span>
<span class="sd">    is as follows:</span>

<span class="sd">    .. code-block:: none</span>

<span class="sd">        {</span>
<span class="sd">            &quot;node_type&quot;: [ [ part1_start, part1_end ],</span>
<span class="sd">                           [ part2_start, part2_end ],</span>
<span class="sd">                           ... ],</span>
<span class="sd">            ...</span>
<span class="sd">        },</span>

<span class="sd">    Essentially, ``node_map`` and ``edge_map`` are dictionaries. The keys are</span>
<span class="sd">    node etypes and canonical edge types respectively. The values are lists of pairs</span>
<span class="sd">    containing the start and end of the ID range for the corresponding types in a partition.</span>
<span class="sd">    The length of the list is the number of</span>
<span class="sd">    partitions; each element in the list is a tuple that stores the start and the end of</span>
<span class="sd">    an ID range for a particular node/edge type in the partition.</span>

<span class="sd">    The graph structure of a partition is stored in a file with the DGLGraph format.</span>
<span class="sd">    Nodes in each partition is *relabeled* to always start with zero. We call the node</span>
<span class="sd">    ID in the original graph, *global ID*, while the relabeled ID in each partition,</span>
<span class="sd">    *local ID*. Each partition graph has an integer node data tensor stored under name</span>
<span class="sd">    `dgl.NID` and each value is the node&#39;s global ID. Similarly, edges are relabeled too</span>
<span class="sd">    and the mapping from local ID to global ID is stored as an integer edge data tensor</span>
<span class="sd">    under name `dgl.EID`. For a heterogeneous graph, the DGLGraph also contains a node</span>
<span class="sd">    data `dgl.NTYPE` for node type and an edge data `dgl.ETYPE` for the edge type.</span>

<span class="sd">    The partition graph contains additional node data (&quot;inner_node&quot;) and</span>
<span class="sd">    edge data (&quot;inner_edge&quot;):</span>

<span class="sd">    * &quot;inner_node&quot; indicates whether a node belongs to a partition.</span>
<span class="sd">    * &quot;inner_edge&quot; indicates whether an edge belongs to a partition.</span>

<span class="sd">    Node and edge features are splitted and stored together with each graph partition.</span>
<span class="sd">    All node/edge features in a partition are stored in a file with DGL format. The node/edge</span>
<span class="sd">    features are stored in dictionaries, in which the key is the node/edge data name and</span>
<span class="sd">    the value is a tensor. We do not store features of HALO nodes and edges.</span>

<span class="sd">    When performing Metis partitioning, we can put some constraint on the partitioning.</span>
<span class="sd">    Current, it supports two constrants to balance the partitioning. By default, Metis</span>
<span class="sd">    always tries to balance the number of nodes in each partition.</span>

<span class="sd">    * ``balance_ntypes`` balances the number of nodes of different types in each partition.</span>
<span class="sd">    * ``balance_edges`` balances the number of edges in each partition.</span>

<span class="sd">    To balance the node types, a user needs to pass a vector of N elements to indicate</span>
<span class="sd">    the type of each node. N is the number of nodes in the input graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : DGLGraph</span>
<span class="sd">        The input graph to partition</span>
<span class="sd">    graph_name : str</span>
<span class="sd">        The name of the graph. The name will be used to construct</span>
<span class="sd">        :py:meth:`~dgl.distributed.DistGraph`.</span>
<span class="sd">    num_parts : int</span>
<span class="sd">        The number of partitions</span>
<span class="sd">    out_path : str</span>
<span class="sd">        The path to store the files for all partitioned data.</span>
<span class="sd">    num_hops : int, optional</span>
<span class="sd">        The number of hops of HALO nodes we construct on a partition graph structure.</span>
<span class="sd">        The default value is 1.</span>
<span class="sd">    part_method : str, optional</span>
<span class="sd">        The partition method. It supports &quot;random&quot; and &quot;metis&quot;. The default value is &quot;metis&quot;.</span>
<span class="sd">    balance_ntypes : tensor, optional</span>
<span class="sd">        Node type of each node. This is a 1D-array of integers. Its values indicates the node</span>
<span class="sd">        type of each node. This argument is used by Metis partition. When the argument is</span>
<span class="sd">        specified, the Metis algorithm will try to partition the input graph into partitions where</span>
<span class="sd">        each partition has roughly the same number of nodes for each node type. The default value</span>
<span class="sd">        is None, which means Metis partitions the graph to only balance the number of nodes.</span>
<span class="sd">    balance_edges : bool</span>
<span class="sd">        Indicate whether to balance the edges in each partition. This argument is used by</span>
<span class="sd">        the Metis algorithm.</span>
<span class="sd">    return_mapping : bool</span>
<span class="sd">        Indicate whether to return the mapping between shuffled node/edge IDs and the original</span>
<span class="sd">        node/edge IDs.</span>
<span class="sd">    num_trainers_per_machine : int, optional</span>
<span class="sd">        The number of trainers per machine. If is not 1, the whole graph will be first partitioned</span>
<span class="sd">        to each trainer, that is num_parts*num_trainers_per_machine parts. And the trainer ids of</span>
<span class="sd">        each node will be stored in the node feature &#39;trainer_id&#39;. Then the partitions of trainers</span>
<span class="sd">        on the same machine will be coalesced into one larger partition. The final number of</span>
<span class="sd">        partitions is `num_part`.</span>
<span class="sd">    objtype : str, &quot;cut&quot; or &quot;vol&quot;</span>
<span class="sd">        Set the objective as edge-cut minimization or communication volume minimization. This</span>
<span class="sd">        argument is used by the Metis algorithm.</span>
<span class="sd">    graph_formats : str or list[str]</span>
<span class="sd">        Save partitions in specified formats. It could be any combination of ``coo``,</span>
<span class="sd">        ``csc`` and ``csr``. If not specified, save one format only according to what</span>
<span class="sd">        format is available. If multiple formats are available, selection priority</span>
<span class="sd">        from high to low is ``coo``, ``csc``, ``csr``.</span>
<span class="sd">    use_graphbolt : bool, optional</span>
<span class="sd">        Whether to save partitions in GraphBolt format. Default: False.</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        Other keyword arguments for converting DGL partitions to GraphBolt.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tensor or dict of tensors, optional</span>
<span class="sd">        If `return_mapping=True`, return a 1D tensor that indicates the mapping between shuffled</span>
<span class="sd">        node IDs and the original node IDs for a homogeneous graph; return a dict of 1D tensors</span>
<span class="sd">        whose key is the node type and value is a 1D tensor mapping between shuffled node IDs and</span>
<span class="sd">        the original node IDs for each node type for a heterogeneous graph.</span>
<span class="sd">    Tensor or dict of tensors, optional</span>
<span class="sd">        If `return_mapping=True`, return a 1D tensor that indicates the mapping between shuffled</span>
<span class="sd">        edge IDs and the original edge IDs for a homogeneous graph; return a dict of 1D tensors</span>
<span class="sd">        whose key is the edge type and value is a 1D tensor mapping between shuffled edge IDs and</span>
<span class="sd">        the original edge IDs for each edge type for a heterogeneous graph.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; dgl.distributed.partition_graph(g, &#39;test&#39;, 4, num_hops=1, part_method=&#39;metis&#39;,</span>
<span class="sd">    ...                                 out_path=&#39;output/&#39;,</span>
<span class="sd">    ...                                 balance_ntypes=g.ndata[&#39;train_mask&#39;],</span>
<span class="sd">    ...                                 balance_edges=True)</span>
<span class="sd">    &gt;&gt;&gt; (</span>
<span class="sd">    ...     g, node_feats, edge_feats, gpb, graph_name, ntypes_list, etypes_list,</span>
<span class="sd">    ... ) = dgl.distributed.load_partition(&#39;output/test.json&#39;, 0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># &#39;coo&#39; is required for partition</span>
    <span class="k">assert</span> <span class="s2">&quot;coo&quot;</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">formats</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="p">),</span> <span class="s2">&quot;&#39;coo&#39; format should be allowed for partitioning graph.&quot;</span>

    <span class="k">def</span> <span class="nf">get_homogeneous</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">balance_ntypes</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_homogeneous</span><span class="p">:</span>
            <span class="n">sim_g</span> <span class="o">=</span> <span class="n">to_homogeneous</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">balance_ntypes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">balance_ntypes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">bal_ntypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">balance_ntypes</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bal_ntypes</span> <span class="o">=</span> <span class="n">balance_ntypes</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">balance_ntypes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Here we assign node types for load balancing.</span>
            <span class="c1"># The new node types includes the ones provided by users.</span>
            <span class="n">num_ntypes</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">ntypes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">balance_ntypes</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;bal_ntype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">F</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">balance_ntypes</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">F</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_ntypes</span>
                    <span class="p">)</span>
                    <span class="n">uniq_ntypes</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">balance_ntypes</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                        <span class="n">F</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">uniq_ntypes</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniq_ntypes</span><span class="p">))</span>
                    <span class="p">)</span>
                    <span class="n">num_ntypes</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_ntypes</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;bal_ntype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">F</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">g</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">(</span><span class="n">key</span><span class="p">),),</span> <span class="n">F</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
                        <span class="o">*</span> <span class="n">num_ntypes</span>
                    <span class="p">)</span>
                    <span class="n">num_ntypes</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">sim_g</span> <span class="o">=</span> <span class="n">to_homogeneous</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ndata</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;bal_ntype&quot;</span><span class="p">])</span>
            <span class="n">bal_ntypes</span> <span class="o">=</span> <span class="n">sim_g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s2">&quot;bal_ntype&quot;</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;The graph has </span><span class="si">{}</span><span class="s2"> node types and balance among </span><span class="si">{}</span><span class="s2"> types&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">ntypes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bal_ntypes</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># We now no longer need them.</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">ntypes</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;bal_ntype&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">sim_g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s2">&quot;bal_ntype&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sim_g</span> <span class="o">=</span> <span class="n">to_homogeneous</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="n">bal_ntypes</span> <span class="o">=</span> <span class="n">sim_g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NTYPE</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sim_g</span><span class="p">,</span> <span class="n">bal_ntypes</span>

    <span class="k">if</span> <span class="n">objtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cut&quot;</span><span class="p">,</span> <span class="s2">&quot;vol&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span>

    <span class="k">if</span> <span class="n">num_parts</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">sim_g</span><span class="p">,</span> <span class="n">balance_ntypes</span> <span class="o">=</span> <span class="n">get_homogeneous</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">balance_ntypes</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Converting to homogeneous graph takes </span><span class="si">{:.3f}</span><span class="s2">s, peak mem: </span><span class="si">{:.3f}</span><span class="s2"> GB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">get_peak_mem</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">num_trainers_per_machine</span> <span class="o">&gt;=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">num_trainers_per_machine</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># First partition the whole graph to each trainer and save the trainer ids in</span>
            <span class="c1"># the node feature &quot;trainer_id&quot;.</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">node_parts</span> <span class="o">=</span> <span class="n">metis_partition_assignment</span><span class="p">(</span>
                <span class="n">sim_g</span><span class="p">,</span>
                <span class="n">num_parts</span> <span class="o">*</span> <span class="n">num_trainers_per_machine</span><span class="p">,</span>
                <span class="n">balance_ntypes</span><span class="o">=</span><span class="n">balance_ntypes</span><span class="p">,</span>
                <span class="n">balance_edges</span><span class="o">=</span><span class="n">balance_edges</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;k-way&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_set_trainer_ids</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sim_g</span><span class="p">,</span> <span class="n">node_parts</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Assigning nodes to METIS partitions takes </span><span class="si">{:.3f}</span><span class="s2">s, peak mem: </span><span class="si">{:.3f}</span><span class="s2"> GB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">get_peak_mem</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">node_parts</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sim_g</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">(),),</span> <span class="n">F</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">sim_g</span><span class="o">.</span><span class="n">clone</span><span class="p">()}</span>
        <span class="n">orig_nids</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NID</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim_g</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">())</span>
        <span class="n">orig_eids</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">EID</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim_g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())</span>
        <span class="c1"># For one partition, we don&#39;t really shuffle nodes and edges. We just need to simulate</span>
        <span class="c1"># it and set node data and edge data of orig_id.</span>
        <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s2">&quot;orig_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_nids</span>
        <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="s2">&quot;orig_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_eids</span>
        <span class="k">if</span> <span class="n">return_mapping</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_homogeneous</span><span class="p">:</span>
                <span class="n">orig_nids</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim_g</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">())</span>
                <span class="n">orig_eids</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim_g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">orig_nids</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">ntype</span><span class="p">:</span> <span class="n">F</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">(</span><span class="n">ntype</span><span class="p">))</span> <span class="k">for</span> <span class="n">ntype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">ntypes</span>
                <span class="p">}</span>
                <span class="n">orig_eids</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">etype</span><span class="p">:</span> <span class="n">F</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(</span><span class="n">etype</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">etype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">canonical_etypes</span>
                <span class="p">}</span>
        <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s2">&quot;inner_node&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
            <span class="p">(</span><span class="n">sim_g</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">(),),</span>
            <span class="n">RESERVED_FIELD_DTYPE</span><span class="p">[</span><span class="s2">&quot;inner_node&quot;</span><span class="p">],</span>
            <span class="n">F</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="s2">&quot;inner_edge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
            <span class="p">(</span><span class="n">sim_g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(),),</span>
            <span class="n">RESERVED_FIELD_DTYPE</span><span class="p">[</span><span class="s2">&quot;inner_edge&quot;</span><span class="p">],</span>
            <span class="n">F</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">part_method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;metis&quot;</span><span class="p">,</span> <span class="s2">&quot;random&quot;</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">sim_g</span><span class="p">,</span> <span class="n">balance_ntypes</span> <span class="o">=</span> <span class="n">get_homogeneous</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">balance_ntypes</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Converting to homogeneous graph takes </span><span class="si">{:.3f}</span><span class="s2">s, peak mem: </span><span class="si">{:.3f}</span><span class="s2"> GB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">get_peak_mem</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">part_method</span> <span class="o">==</span> <span class="s2">&quot;metis&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">num_trainers_per_machine</span> <span class="o">&gt;=</span> <span class="mi">1</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">num_trainers_per_machine</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># First partition the whole graph to each trainer and save the trainer ids in</span>
                <span class="c1"># the node feature &quot;trainer_id&quot;.</span>
                <span class="n">node_parts</span> <span class="o">=</span> <span class="n">metis_partition_assignment</span><span class="p">(</span>
                    <span class="n">sim_g</span><span class="p">,</span>
                    <span class="n">num_parts</span> <span class="o">*</span> <span class="n">num_trainers_per_machine</span><span class="p">,</span>
                    <span class="n">balance_ntypes</span><span class="o">=</span><span class="n">balance_ntypes</span><span class="p">,</span>
                    <span class="n">balance_edges</span><span class="o">=</span><span class="n">balance_edges</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;k-way&quot;</span><span class="p">,</span>
                    <span class="n">objtype</span><span class="o">=</span><span class="n">objtype</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">_set_trainer_ids</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sim_g</span><span class="p">,</span> <span class="n">node_parts</span><span class="p">)</span>

                <span class="c1"># And then coalesce the partitions of trainers on the same machine into one</span>
                <span class="c1"># larger partition.</span>
                <span class="n">node_parts</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">floor_div</span><span class="p">(</span><span class="n">node_parts</span><span class="p">,</span> <span class="n">num_trainers_per_machine</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_parts</span> <span class="o">=</span> <span class="n">metis_partition_assignment</span><span class="p">(</span>
                    <span class="n">sim_g</span><span class="p">,</span>
                    <span class="n">num_parts</span><span class="p">,</span>
                    <span class="n">balance_ntypes</span><span class="o">=</span><span class="n">balance_ntypes</span><span class="p">,</span>
                    <span class="n">balance_edges</span><span class="o">=</span><span class="n">balance_edges</span><span class="p">,</span>
                    <span class="n">objtype</span><span class="o">=</span><span class="n">objtype</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Assigning nodes to METIS partitions takes </span><span class="si">{:.3f}</span><span class="s2">s, peak mem: </span><span class="si">{:.3f}</span><span class="s2"> GB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">get_peak_mem</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_parts</span> <span class="o">=</span> <span class="n">random_choice</span><span class="p">(</span><span class="n">num_parts</span><span class="p">,</span> <span class="n">sim_g</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">())</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">parts</span><span class="p">,</span> <span class="n">orig_nids</span><span class="p">,</span> <span class="n">orig_eids</span> <span class="o">=</span> <span class="n">partition_graph_with_halo</span><span class="p">(</span>
            <span class="n">sim_g</span><span class="p">,</span> <span class="n">node_parts</span><span class="p">,</span> <span class="n">num_hops</span><span class="p">,</span> <span class="n">reshuffle</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Splitting the graph into partitions takes </span><span class="si">{:.3f}</span><span class="s2">s, peak mem: </span><span class="si">{:.3f}</span><span class="s2"> GB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">get_peak_mem</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">return_mapping</span><span class="p">:</span>
            <span class="n">orig_nids</span><span class="p">,</span> <span class="n">orig_eids</span> <span class="o">=</span> <span class="n">_get_orig_ids</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sim_g</span><span class="p">,</span> <span class="n">orig_nids</span><span class="p">,</span> <span class="n">orig_eids</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown partitioning method: &quot;</span> <span class="o">+</span> <span class="n">part_method</span><span class="p">)</span>

    <span class="c1"># If the input is a heterogeneous graph, get the original node types and original node IDs.</span>
    <span class="c1"># `part&#39; has three types of node data at this point.</span>
    <span class="c1"># NTYPE: the node type.</span>
    <span class="c1"># orig_id: the global node IDs in the homogeneous version of input graph.</span>
    <span class="c1"># NID: the global node IDs in the reshuffled homogeneous version of the input graph.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_homogeneous</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
            <span class="n">orig_ids</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s2">&quot;orig_id&quot;</span><span class="p">]</span>
            <span class="n">ntype</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span><span class="n">sim_g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NTYPE</span><span class="p">],</span> <span class="n">orig_ids</span><span class="p">)</span>
            <span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NTYPE</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">ntype</span><span class="p">,</span> <span class="n">RESERVED_FIELD_DTYPE</span><span class="p">[</span><span class="n">NTYPE</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                <span class="n">F</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">ntype</span><span class="p">)</span> <span class="o">==</span> <span class="n">F</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NTYPE</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="c1"># Get the original edge types and original edge IDs.</span>
            <span class="n">orig_ids</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="s2">&quot;orig_id&quot;</span><span class="p">]</span>
            <span class="n">etype</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span><span class="n">sim_g</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">ETYPE</span><span class="p">],</span> <span class="n">orig_ids</span><span class="p">)</span>
            <span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">ETYPE</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">etype</span><span class="p">,</span> <span class="n">RESERVED_FIELD_DTYPE</span><span class="p">[</span><span class="n">ETYPE</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                <span class="n">F</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">etype</span><span class="p">)</span> <span class="o">==</span> <span class="n">F</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">ETYPE</span><span class="p">])</span>
            <span class="p">)</span>

            <span class="c1"># Calculate the global node IDs to per-node IDs mapping.</span>
            <span class="n">inner_ntype</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span>
                <span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NTYPE</span><span class="p">],</span> <span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s2">&quot;inner_node&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">inner_nids</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span>
                <span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NID</span><span class="p">],</span> <span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s2">&quot;inner_node&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">ntype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">ntypes</span><span class="p">:</span>
                <span class="n">inner_ntype_mask</span> <span class="o">=</span> <span class="n">inner_ntype</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">get_ntype_id</span><span class="p">(</span><span class="n">ntype</span><span class="p">)</span>
                <span class="n">typed_nids</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">inner_nids</span><span class="p">,</span> <span class="n">inner_ntype_mask</span><span class="p">)</span>
                <span class="c1"># inner node IDs are in a contiguous ID range.</span>
                <span class="n">expected_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">(</span><span class="n">typed_nids</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">(</span><span class="n">typed_nids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">typed_nids</span><span class="p">)</span> <span class="o">==</span> <span class="n">expected_range</span><span class="p">)</span>
            <span class="c1"># Calculate the global edge IDs to per-edge IDs mapping.</span>
            <span class="n">inner_etype</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span>
                <span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">ETYPE</span><span class="p">],</span> <span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="s2">&quot;inner_edge&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">inner_eids</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span>
                <span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">EID</span><span class="p">],</span> <span class="n">parts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="s2">&quot;inner_edge&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">etype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">canonical_etypes</span><span class="p">:</span>
                <span class="n">inner_etype_mask</span> <span class="o">=</span> <span class="n">inner_etype</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">get_etype_id</span><span class="p">(</span><span class="n">etype</span><span class="p">)</span>
                <span class="n">typed_eids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                    <span class="n">F</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">inner_eids</span><span class="p">,</span> <span class="n">inner_etype_mask</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                    <span class="n">typed_eids</span>
                    <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">typed_eids</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">typed_eids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>

    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mo">0o775</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">tot_num_inner_edges</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">out_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">out_path</span><span class="p">)</span>

    <span class="c1"># With reshuffling, we can ensure that all nodes and edges are reshuffled</span>
    <span class="c1"># and are in contiguous ID space.</span>
    <span class="k">if</span> <span class="n">num_parts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">node_map_val</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">edge_map_val</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ntype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">ntypes</span><span class="p">:</span>
            <span class="n">ntype_id</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_ntype_id</span><span class="p">(</span><span class="n">ntype</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">node_map_val</span><span class="p">[</span><span class="n">ntype</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
                <span class="n">inner_node_mask</span> <span class="o">=</span> <span class="n">_get_inner_node_mask</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ntype_id</span><span class="p">)</span>
                <span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">F</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">inner_node_mask</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="n">inner_nids</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span>
                    <span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NID</span><span class="p">],</span> <span class="n">inner_node_mask</span>
                <span class="p">)</span>
                <span class="n">node_map_val</span><span class="p">[</span><span class="n">ntype</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">(</span><span class="n">inner_nids</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">(</span><span class="n">inner_nids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">val</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">(</span><span class="n">ntype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">etype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">canonical_etypes</span><span class="p">:</span>
            <span class="n">etype_id</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_etype_id</span><span class="p">(</span><span class="n">etype</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">edge_map_val</span><span class="p">[</span><span class="n">etype</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
                <span class="n">inner_edge_mask</span> <span class="o">=</span> <span class="n">_get_inner_edge_mask</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">etype_id</span><span class="p">)</span>
                <span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">F</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">inner_edge_mask</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="n">inner_eids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                    <span class="n">F</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span>
                        <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">EID</span><span class="p">],</span> <span class="n">inner_edge_mask</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">edge_map_val</span><span class="p">[</span><span class="n">etype</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">inner_eids</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">inner_eids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">val</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(</span><span class="n">etype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">node_map_val</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">edge_map_val</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ntype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">ntypes</span><span class="p">:</span>
            <span class="n">ntype_id</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_ntype_id</span><span class="p">(</span><span class="n">ntype</span><span class="p">)</span>
            <span class="n">inner_node_mask</span> <span class="o">=</span> <span class="n">_get_inner_node_mask</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ntype_id</span><span class="p">)</span>
            <span class="n">inner_nids</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NID</span><span class="p">],</span> <span class="n">inner_node_mask</span><span class="p">)</span>
            <span class="n">node_map_val</span><span class="p">[</span><span class="n">ntype</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">(</span><span class="n">inner_nids</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">(</span><span class="n">inner_nids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">]</span>
        <span class="k">for</span> <span class="n">etype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">canonical_etypes</span><span class="p">:</span>
            <span class="n">etype_id</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_etype_id</span><span class="p">(</span><span class="n">etype</span><span class="p">)</span>
            <span class="n">inner_edge_mask</span> <span class="o">=</span> <span class="n">_get_inner_edge_mask</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">etype_id</span><span class="p">)</span>
            <span class="n">inner_eids</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">EID</span><span class="p">],</span> <span class="n">inner_edge_mask</span><span class="p">)</span>
            <span class="n">edge_map_val</span><span class="p">[</span><span class="n">etype</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">(</span><span class="n">inner_eids</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">(</span><span class="n">inner_eids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">]</span>

        <span class="c1"># Double check that the node IDs in the global ID space are sorted.</span>
        <span class="k">for</span> <span class="n">ntype</span> <span class="ow">in</span> <span class="n">node_map_val</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">node_map_val</span><span class="p">[</span><span class="n">ntype</span><span class="p">]])</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">val</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">for</span> <span class="n">etype</span> <span class="ow">in</span> <span class="n">edge_map_val</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">edge_map_val</span><span class="p">[</span><span class="n">etype</span><span class="p">]])</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">val</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">ntypes</span> <span class="o">=</span> <span class="p">{</span><span class="n">ntype</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">get_ntype_id</span><span class="p">(</span><span class="n">ntype</span><span class="p">)</span> <span class="k">for</span> <span class="n">ntype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">ntypes</span><span class="p">}</span>
    <span class="n">etypes</span> <span class="o">=</span> <span class="p">{</span><span class="n">etype</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">get_etype_id</span><span class="p">(</span><span class="n">etype</span><span class="p">)</span> <span class="k">for</span> <span class="n">etype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">canonical_etypes</span><span class="p">}</span>
    <span class="n">part_metadata</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;graph_name&quot;</span><span class="p">:</span> <span class="n">graph_name</span><span class="p">,</span>
        <span class="s2">&quot;num_nodes&quot;</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">(),</span>
        <span class="s2">&quot;num_edges&quot;</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(),</span>
        <span class="s2">&quot;part_method&quot;</span><span class="p">:</span> <span class="n">part_method</span><span class="p">,</span>
        <span class="s2">&quot;num_parts&quot;</span><span class="p">:</span> <span class="n">num_parts</span><span class="p">,</span>
        <span class="s2">&quot;halo_hops&quot;</span><span class="p">:</span> <span class="n">num_hops</span><span class="p">,</span>
        <span class="s2">&quot;node_map&quot;</span><span class="p">:</span> <span class="n">node_map_val</span><span class="p">,</span>
        <span class="s2">&quot;edge_map&quot;</span><span class="p">:</span> <span class="n">edge_map_val</span><span class="p">,</span>
        <span class="s2">&quot;ntypes&quot;</span><span class="p">:</span> <span class="n">ntypes</span><span class="p">,</span>
        <span class="s2">&quot;etypes&quot;</span><span class="p">:</span> <span class="n">etypes</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">part_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_parts</span><span class="p">):</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="n">part_id</span><span class="p">]</span>

        <span class="c1"># Get the node/edge features of each partition.</span>
        <span class="n">node_feats</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">edge_feats</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">num_parts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ntype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">ntypes</span><span class="p">:</span>
                <span class="n">ntype_id</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_ntype_id</span><span class="p">(</span><span class="n">ntype</span><span class="p">)</span>
                <span class="c1"># To get the edges in the input graph, we should use original node IDs.</span>
                <span class="c1"># Both orig_id and NID stores the per-node-type IDs.</span>
                <span class="n">ndata_name</span> <span class="o">=</span> <span class="s2">&quot;orig_id&quot;</span>
                <span class="n">inner_node_mask</span> <span class="o">=</span> <span class="n">_get_inner_node_mask</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">ntype_id</span><span class="p">)</span>
                <span class="c1"># This is global node IDs.</span>
                <span class="n">local_nodes</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span>
                    <span class="n">part</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">ndata_name</span><span class="p">],</span> <span class="n">inner_node_mask</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">ntypes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># If the input is a heterogeneous graph.</span>
                    <span class="n">local_nodes</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span><span class="n">sim_g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NID</span><span class="p">],</span> <span class="n">local_nodes</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;part </span><span class="si">{}</span><span class="s2"> has </span><span class="si">{}</span><span class="s2"> nodes of type </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2"> are inside the partition&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">part_id</span><span class="p">,</span>
                            <span class="n">F</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">(</span>
                                <span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NTYPE</span><span class="p">]</span> <span class="o">==</span> <span class="n">ntype_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                            <span class="p">),</span>
                            <span class="n">ntype</span><span class="p">,</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">local_nodes</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;part </span><span class="si">{}</span><span class="s2"> has </span><span class="si">{}</span><span class="s2"> nodes and </span><span class="si">{}</span><span class="s2"> are inside the partition&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">part_id</span><span class="p">,</span> <span class="n">part</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_nodes</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ntype</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">NID</span><span class="p">,</span> <span class="s2">&quot;inner_node&quot;</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">node_feats</span><span class="p">[</span><span class="n">ntype</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ntype</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">local_nodes</span>
                    <span class="p">)</span>

            <span class="k">for</span> <span class="n">etype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">canonical_etypes</span><span class="p">:</span>
                <span class="n">etype_id</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_etype_id</span><span class="p">(</span><span class="n">etype</span><span class="p">)</span>
                <span class="n">edata_name</span> <span class="o">=</span> <span class="s2">&quot;orig_id&quot;</span>
                <span class="n">inner_edge_mask</span> <span class="o">=</span> <span class="n">_get_inner_edge_mask</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">etype_id</span><span class="p">)</span>
                <span class="c1"># This is global edge IDs.</span>
                <span class="n">local_edges</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span>
                    <span class="n">part</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">edata_name</span><span class="p">],</span> <span class="n">inner_edge_mask</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_homogeneous</span><span class="p">:</span>
                    <span class="n">local_edges</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span><span class="n">sim_g</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">EID</span><span class="p">],</span> <span class="n">local_edges</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;part </span><span class="si">{}</span><span class="s2"> has </span><span class="si">{}</span><span class="s2"> edges of type </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2"> are inside the partition&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">part_id</span><span class="p">,</span>
                            <span class="n">F</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">(</span>
                                <span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">ETYPE</span><span class="p">]</span> <span class="o">==</span> <span class="n">etype_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                            <span class="p">),</span>
                            <span class="n">etype</span><span class="p">,</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">local_edges</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;part </span><span class="si">{}</span><span class="s2"> has </span><span class="si">{}</span><span class="s2"> edges and </span><span class="si">{}</span><span class="s2"> are inside the partition&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">part_id</span><span class="p">,</span> <span class="n">part</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_edges</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">tot_num_inner_edges</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_edges</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">etype</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">EID</span><span class="p">,</span> <span class="s2">&quot;inner_edge&quot;</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">edge_feats</span><span class="p">[</span>
                        <span class="n">_etype_tuple_to_str</span><span class="p">(</span><span class="n">etype</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">name</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">etype</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">local_edges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ntype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">ntypes</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">ntypes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ndata_name</span> <span class="o">=</span> <span class="s2">&quot;orig_id&quot;</span>
                    <span class="n">ntype_id</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_ntype_id</span><span class="p">(</span><span class="n">ntype</span><span class="p">)</span>
                    <span class="n">inner_node_mask</span> <span class="o">=</span> <span class="n">_get_inner_node_mask</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">ntype_id</span><span class="p">)</span>
                    <span class="c1"># This is global node IDs.</span>
                    <span class="n">local_nodes</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span>
                        <span class="n">part</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">ndata_name</span><span class="p">],</span> <span class="n">inner_node_mask</span>
                    <span class="p">)</span>
                    <span class="n">local_nodes</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span><span class="n">sim_g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NID</span><span class="p">],</span> <span class="n">local_nodes</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">local_nodes</span> <span class="o">=</span> <span class="n">sim_g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">NID</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ntype</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">NID</span><span class="p">,</span> <span class="s2">&quot;inner_node&quot;</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">node_feats</span><span class="p">[</span><span class="n">ntype</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ntype</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">local_nodes</span>
                    <span class="p">)</span>
            <span class="k">for</span> <span class="n">etype</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">canonical_etypes</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_homogeneous</span><span class="p">:</span>
                    <span class="n">edata_name</span> <span class="o">=</span> <span class="s2">&quot;orig_id&quot;</span>
                    <span class="n">etype_id</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_etype_id</span><span class="p">(</span><span class="n">etype</span><span class="p">)</span>
                    <span class="n">inner_edge_mask</span> <span class="o">=</span> <span class="n">_get_inner_edge_mask</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">etype_id</span><span class="p">)</span>
                    <span class="c1"># This is global edge IDs.</span>
                    <span class="n">local_edges</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span>
                        <span class="n">part</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">edata_name</span><span class="p">],</span> <span class="n">inner_edge_mask</span>
                    <span class="p">)</span>
                    <span class="n">local_edges</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span><span class="n">sim_g</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">EID</span><span class="p">],</span> <span class="n">local_edges</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">local_edges</span> <span class="o">=</span> <span class="n">sim_g</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">EID</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">etype</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">EID</span><span class="p">,</span> <span class="s2">&quot;inner_edge&quot;</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">edge_feats</span><span class="p">[</span>
                        <span class="n">_etype_tuple_to_str</span><span class="p">(</span><span class="n">etype</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">name</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gather_row</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">etype</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">local_edges</span><span class="p">)</span>
        <span class="c1"># delete `orig_id` from ndata/edata</span>
        <span class="k">del</span> <span class="n">part</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s2">&quot;orig_id&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">part</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="s2">&quot;orig_id&quot;</span><span class="p">]</span>

        <span class="n">part_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_path</span><span class="p">,</span> <span class="s2">&quot;part&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">part_id</span><span class="p">))</span>
        <span class="n">node_feat_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">part_dir</span><span class="p">,</span> <span class="s2">&quot;node_feat.dgl&quot;</span><span class="p">)</span>
        <span class="n">edge_feat_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">part_dir</span><span class="p">,</span> <span class="s2">&quot;edge_feat.dgl&quot;</span><span class="p">)</span>
        <span class="n">part_graph_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">part_dir</span><span class="p">,</span> <span class="s2">&quot;graph.dgl&quot;</span><span class="p">)</span>
        <span class="n">part_metadata</span><span class="p">[</span><span class="s2">&quot;part-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">part_id</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;node_feats&quot;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">node_feat_file</span><span class="p">,</span> <span class="n">out_path</span><span class="p">),</span>
            <span class="s2">&quot;edge_feats&quot;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">edge_feat_file</span><span class="p">,</span> <span class="n">out_path</span><span class="p">),</span>
            <span class="s2">&quot;part_graph&quot;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">part_graph_file</span><span class="p">,</span> <span class="n">out_path</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">part_dir</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mo">0o775</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">save_tensors</span><span class="p">(</span><span class="n">node_feat_file</span><span class="p">,</span> <span class="n">node_feats</span><span class="p">)</span>
        <span class="n">save_tensors</span><span class="p">(</span><span class="n">edge_feat_file</span><span class="p">,</span> <span class="n">edge_feats</span><span class="p">)</span>

        <span class="n">sort_etypes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">etypes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="n">_save_graphs</span><span class="p">(</span>
            <span class="n">part_graph_file</span><span class="p">,</span>
            <span class="p">[</span><span class="n">part</span><span class="p">],</span>
            <span class="n">formats</span><span class="o">=</span><span class="n">graph_formats</span><span class="p">,</span>
            <span class="n">sort_etypes</span><span class="o">=</span><span class="n">sort_etypes</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;Save partitions: </span><span class="si">{:.3f}</span><span class="s2"> seconds, peak memory: </span><span class="si">{:.3f}</span><span class="s2"> GB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">get_peak_mem</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">part_config</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_path</span><span class="p">,</span> <span class="n">graph_name</span> <span class="o">+</span> <span class="s2">&quot;.json&quot;</span><span class="p">)</span>
    <span class="n">_dump_part_config</span><span class="p">(</span><span class="n">part_config</span><span class="p">,</span> <span class="n">part_metadata</span><span class="p">)</span>

    <span class="n">num_cuts</span> <span class="o">=</span> <span class="n">sim_g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">-</span> <span class="n">tot_num_inner_edges</span>
    <span class="k">if</span> <span class="n">num_parts</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">num_cuts</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;There are </span><span class="si">{}</span><span class="s2"> edges in the graph and </span><span class="si">{}</span><span class="s2"> edge cuts for </span><span class="si">{}</span><span class="s2"> partitions.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(),</span> <span class="n">num_cuts</span><span class="p">,</span> <span class="n">num_parts</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">use_graphbolt</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;graph_formats&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph_formats</span>
        <span class="n">dgl_partition_to_graphbolt</span><span class="p">(</span>
            <span class="n">part_config</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">return_mapping</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">orig_nids</span><span class="p">,</span> <span class="n">orig_eids</span></div>



<span class="c1"># [TODO][Rui] Due to int64_t is expected in RPC, we have to limit the data type</span>
<span class="c1"># of node/edge IDs to int64_t. See more details in #7175.</span>
<span class="n">DTYPES_TO_CHECK</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span>
    <span class="n">NID</span><span class="p">:</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span>
    <span class="n">EID</span><span class="p">:</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span>
    <span class="n">NTYPE</span><span class="p">:</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span>
    <span class="n">ETYPE</span><span class="p">:</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span>
    <span class="s2">&quot;inner_node&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">uint8</span><span class="p">],</span>
    <span class="s2">&quot;inner_edge&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">uint8</span><span class="p">],</span>
    <span class="s2">&quot;part_id&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_cast_to_minimum_dtype</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="n">dtypes_to_check</span> <span class="o">=</span> <span class="n">DTYPES_TO_CHECK</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">DTYPES_TO_CHECK</span><span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dtypes_to_check</span><span class="p">:</span>
        <span class="n">dgl_warning</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Skipping as the data type of field </span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2"> is </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;while supported data types are </span><span class="si">{</span><span class="n">dtypes_to_check</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">dtypes_to_check</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">predicate</span> <span class="o">&lt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>


<div class="viewcode-block" id="dgl_partition_to_graphbolt">
<a class="viewcode-back" href="../../../generated/dgl.distributed.dgl_partition_to_graphbolt.html#dgl.distributed.dgl_partition_to_graphbolt">[docs]</a>
<span class="k">def</span> <span class="nf">dgl_partition_to_graphbolt</span><span class="p">(</span>
    <span class="n">part_config</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">store_eids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">store_inner_node</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">store_inner_edge</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">graph_formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert partitions of dgl to FusedCSCSamplingGraph of GraphBolt.</span>

<span class="sd">    This API converts `DGLGraph` partitions to `FusedCSCSamplingGraph` which is</span>
<span class="sd">    dedicated for sampling in `GraphBolt`. New graphs will be stored alongside</span>
<span class="sd">    original graph as `fused_csc_sampling_graph.pt`.</span>

<span class="sd">    In the near future, partitions are supposed to be saved as</span>
<span class="sd">    `FusedCSCSamplingGraph` directly. At that time, this API should be deprecated.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    part_config : str</span>
<span class="sd">        The partition configuration JSON file.</span>
<span class="sd">    store_eids : bool, optional</span>
<span class="sd">        Whether to store edge IDs in the new graph. Default: True.</span>
<span class="sd">    store_inner_node : bool, optional</span>
<span class="sd">        Whether to store inner node mask in the new graph. Default: False.</span>
<span class="sd">    store_inner_edge : bool, optional</span>
<span class="sd">        Whether to store inner edge mask in the new graph. Default: False.</span>
<span class="sd">    graph_formats : str or list[str], optional</span>
<span class="sd">        Save partitions in specified formats. It could be any combination of</span>
<span class="sd">        `coo`, `csc`. As `csc` format is mandatory for `FusedCSCSamplingGraph`,</span>
<span class="sd">        it is not necessary to specify this argument. It&#39;s mainly for</span>
<span class="sd">        specifying `coo` format to save edge ID mapping and destination node</span>
<span class="sd">        IDs. If not specified, whether to save `coo` format is determined by</span>
<span class="sd">        the availability of the format in DGL partitions. Default: None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">debug_mode</span> <span class="o">=</span> <span class="s2">&quot;DGL_DIST_DEBUG&quot;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span>
    <span class="k">if</span> <span class="n">debug_mode</span><span class="p">:</span>
        <span class="n">dgl_warning</span><span class="p">(</span>
            <span class="s2">&quot;Running in debug mode which means all attributes of DGL partitions&quot;</span>
            <span class="s2">&quot; will be saved to the new format.&quot;</span>
        <span class="p">)</span>
    <span class="n">part_meta</span> <span class="o">=</span> <span class="n">_load_part_config</span><span class="p">(</span><span class="n">part_config</span><span class="p">)</span>
    <span class="n">new_part_meta</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">part_meta</span><span class="p">)</span>
    <span class="n">num_parts</span> <span class="o">=</span> <span class="n">part_meta</span><span class="p">[</span><span class="s2">&quot;num_parts&quot;</span><span class="p">]</span>

    <span class="c1"># Utility functions.</span>
    <span class="k">def</span> <span class="nf">is_homogeneous</span><span class="p">(</span><span class="n">ntypes</span><span class="p">,</span> <span class="n">etypes</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">ntypes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">etypes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">init_type_per_edge</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">gpb</span><span class="p">):</span>
        <span class="n">etype_ids</span> <span class="o">=</span> <span class="n">gpb</span><span class="o">.</span><span class="n">map_to_per_etype</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">EID</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">etype_ids</span>

    <span class="c1"># [Rui] DGL partitions are always saved as homogeneous graphs even though</span>
    <span class="c1"># the original graph is heterogeneous. But heterogeneous information like</span>
    <span class="c1"># node/edge types are saved as node/edge data alongside with partitions.</span>
    <span class="c1"># What needs more attention is that due to the existence of HALO nodes in</span>
    <span class="c1"># each partition, the local node IDs are not sorted according to the node</span>
    <span class="c1"># types. So we fail to assign ``node_type_offset`` as required by GraphBolt.</span>
    <span class="c1"># But this is not a problem since such information is not used in sampling.</span>
    <span class="c1"># We can simply pass None to it.</span>

    <span class="c1"># Iterate over partitions.</span>
    <span class="k">for</span> <span class="n">part_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_parts</span><span class="p">):</span>
        <span class="n">graph</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">gpb</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_partition</span><span class="p">(</span>
            <span class="n">part_config</span><span class="p">,</span> <span class="n">part_id</span><span class="p">,</span> <span class="n">load_feats</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">ntypes</span><span class="p">,</span> <span class="n">etypes</span> <span class="o">=</span> <span class="n">load_partition_book</span><span class="p">(</span><span class="n">part_config</span><span class="p">,</span> <span class="n">part_id</span><span class="p">)</span>
        <span class="n">is_homo</span> <span class="o">=</span> <span class="n">is_homogeneous</span><span class="p">(</span><span class="n">ntypes</span><span class="p">,</span> <span class="n">etypes</span><span class="p">)</span>
        <span class="n">node_type_to_id</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="n">is_homo</span>
            <span class="k">else</span> <span class="p">{</span><span class="n">ntype</span><span class="p">:</span> <span class="n">ntid</span> <span class="k">for</span> <span class="n">ntid</span><span class="p">,</span> <span class="n">ntype</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ntypes</span><span class="p">)}</span>
        <span class="p">)</span>
        <span class="n">edge_type_to_id</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="n">is_homo</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">gb</span><span class="o">.</span><span class="n">etype_tuple_to_str</span><span class="p">(</span><span class="n">etype</span><span class="p">):</span> <span class="n">etid</span>
                <span class="k">for</span> <span class="n">etype</span><span class="p">,</span> <span class="n">etid</span> <span class="ow">in</span> <span class="n">etypes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="c1"># Obtain CSC indtpr and indices.</span>
        <span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">edge_ids</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">adj_tensors</span><span class="p">(</span><span class="s2">&quot;csc&quot;</span><span class="p">)</span>

        <span class="c1"># Save node attributes. Detailed attributes are shown below.</span>
        <span class="c1">#  DGL_GB\Attributes  dgl.NID(&quot;_ID&quot;)  dgl.NTYPE(&quot;_TYPE&quot;)  &quot;inner_node&quot;  &quot;part_id&quot;</span>
        <span class="c1">#  DGL_Homograph           ✅                🚫                  ✅          ✅</span>
        <span class="c1">#  GB_Homograph            ✅                🚫               optional       🚫</span>
        <span class="c1">#  DGL_Heterograph         ✅                ✅                  ✅          ✅</span>
        <span class="c1">#  GB_Heterograph          ✅                🚫               optional       🚫</span>
        <span class="n">required_node_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">NID</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">store_inner_node</span><span class="p">:</span>
            <span class="n">required_node_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;inner_node&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug_mode</span><span class="p">:</span>
            <span class="n">required_node_attrs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">ndata</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">node_attributes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">attr</span><span class="p">:</span> <span class="n">graph</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">required_node_attrs</span>
        <span class="p">}</span>

        <span class="c1"># Save edge attributes. Detailed attributes are shown below.</span>
        <span class="c1">#  DGL_GB\Attributes  dgl.EID(&quot;_ID&quot;)  dgl.ETYPE(&quot;_TYPE&quot;)  &quot;inner_edge&quot;</span>
        <span class="c1">#  DGL_Homograph           ✅               🚫                  ✅</span>
        <span class="c1">#  GB_Homograph         optional            🚫               optional</span>
        <span class="c1">#  DGL_Heterograph         ✅               ✅                  ✅</span>
        <span class="c1">#  GB_Heterograph       optional            ✅               optional</span>
        <span class="n">type_per_edge</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_homo</span><span class="p">:</span>
            <span class="n">type_per_edge</span> <span class="o">=</span> <span class="n">init_type_per_edge</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">gpb</span><span class="p">)[</span><span class="n">edge_ids</span><span class="p">]</span>
            <span class="n">type_per_edge</span> <span class="o">=</span> <span class="n">type_per_edge</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">RESERVED_FIELD_DTYPE</span><span class="p">[</span><span class="n">ETYPE</span><span class="p">])</span>
        <span class="n">required_edge_attrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">store_eids</span><span class="p">:</span>
            <span class="n">required_edge_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">EID</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">store_inner_edge</span><span class="p">:</span>
            <span class="n">required_edge_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;inner_edge&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug_mode</span><span class="p">:</span>
            <span class="n">required_edge_attrs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">edge_attributes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">attr</span><span class="p">:</span> <span class="n">graph</span><span class="o">.</span><span class="n">edata</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="n">edge_ids</span><span class="p">]</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">required_edge_attrs</span>
        <span class="p">}</span>
        <span class="c1"># When converting DGLGraph to FusedCSCSamplingGraph, edge IDs are</span>
        <span class="c1"># re-ordered(actually FusedCSCSamplingGraph does not have edge IDs</span>
        <span class="c1"># in nature). So we need to save such re-order info for any</span>
        <span class="c1"># operations that uses original local edge IDs. For now, this is</span>
        <span class="c1"># required by `DistGraph.find_edges()` for link prediction tasks.</span>
        <span class="c1">#</span>
        <span class="c1"># What&#39;s more, in order to find the dst nodes efficiently, we save</span>
        <span class="c1"># dst nodes directly in the edge attributes.</span>
        <span class="c1">#</span>
        <span class="c1"># So we require additional `(2 * E) * dtype` space in total.</span>
        <span class="k">if</span> <span class="n">graph_formats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph_formats</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">graph_formats</span> <span class="o">=</span> <span class="p">[</span><span class="n">graph_formats</span><span class="p">]</span>
        <span class="n">save_coo</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">graph_formats</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;coo&quot;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">formats</span><span class="p">()[</span><span class="s2">&quot;created&quot;</span><span class="p">]</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">graph_formats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;coo&quot;</span> <span class="ow">in</span> <span class="n">graph_formats</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_coo</span><span class="p">:</span>
            <span class="n">edge_attributes</span><span class="p">[</span><span class="n">DGL2GB_EID</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">edge_ids</span><span class="p">)</span>
            <span class="n">edge_attributes</span><span class="p">[</span><span class="n">GB_DST_ID</span><span class="p">]</span> <span class="o">=</span> <span class="n">gb</span><span class="o">.</span><span class="n">expand_indptr</span><span class="p">(</span>
                <span class="n">indptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">indices</span><span class="o">.</span><span class="n">dtype</span>
            <span class="p">)</span>

        <span class="c1"># Cast various data to minimum dtype.</span>
        <span class="c1"># Cast 1: indptr.</span>
        <span class="n">indptr</span> <span class="o">=</span> <span class="n">_cast_to_minimum_dtype</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(),</span> <span class="n">indptr</span><span class="p">)</span>
        <span class="c1"># Cast 2: indices.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">_cast_to_minimum_dtype</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">(),</span> <span class="n">indices</span><span class="p">)</span>
        <span class="c1"># Cast 3: type_per_edge.</span>
        <span class="n">type_per_edge</span> <span class="o">=</span> <span class="n">_cast_to_minimum_dtype</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">etypes</span><span class="p">),</span> <span class="n">type_per_edge</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">ETYPE</span>
        <span class="p">)</span>
        <span class="c1"># Cast 4: node/edge_attributes.</span>
        <span class="n">predicates</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">NID</span><span class="p">:</span> <span class="n">part_meta</span><span class="p">[</span><span class="s2">&quot;num_nodes&quot;</span><span class="p">],</span>
            <span class="s2">&quot;part_id&quot;</span><span class="p">:</span> <span class="n">num_parts</span><span class="p">,</span>
            <span class="n">NTYPE</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">ntypes</span><span class="p">),</span>
            <span class="n">EID</span><span class="p">:</span> <span class="n">part_meta</span><span class="p">[</span><span class="s2">&quot;num_edges&quot;</span><span class="p">],</span>
            <span class="n">ETYPE</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">etypes</span><span class="p">),</span>
            <span class="n">DGL2GB_EID</span><span class="p">:</span> <span class="n">part_meta</span><span class="p">[</span><span class="s2">&quot;num_edges&quot;</span><span class="p">],</span>
            <span class="n">GB_DST_ID</span><span class="p">:</span> <span class="n">part_meta</span><span class="p">[</span><span class="s2">&quot;num_nodes&quot;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">attributes</span> <span class="ow">in</span> <span class="p">[</span><span class="n">node_attributes</span><span class="p">,</span> <span class="n">edge_attributes</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">predicates</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">_cast_to_minimum_dtype</span><span class="p">(</span>
                    <span class="n">predicates</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">field</span><span class="o">=</span><span class="n">key</span>
                <span class="p">)</span>

        <span class="n">csc_graph</span> <span class="o">=</span> <span class="n">gb</span><span class="o">.</span><span class="n">fused_csc_sampling_graph</span><span class="p">(</span>
            <span class="n">indptr</span><span class="p">,</span>
            <span class="n">indices</span><span class="p">,</span>
            <span class="n">node_type_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">type_per_edge</span><span class="o">=</span><span class="n">type_per_edge</span><span class="p">,</span>
            <span class="n">node_attributes</span><span class="o">=</span><span class="n">node_attributes</span><span class="p">,</span>
            <span class="n">edge_attributes</span><span class="o">=</span><span class="n">edge_attributes</span><span class="p">,</span>
            <span class="n">node_type_to_id</span><span class="o">=</span><span class="n">node_type_to_id</span><span class="p">,</span>
            <span class="n">edge_type_to_id</span><span class="o">=</span><span class="n">edge_type_to_id</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">orig_graph_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">part_config</span><span class="p">),</span>
            <span class="n">part_meta</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;part-</span><span class="si">{</span><span class="n">part_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s2">&quot;part_graph&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">csc_graph_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">orig_graph_path</span><span class="p">),</span> <span class="s2">&quot;fused_csc_sampling_graph.pt&quot;</span>
        <span class="p">)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">csc_graph</span><span class="p">,</span> <span class="n">csc_graph_path</span><span class="p">)</span>

        <span class="c1"># Update graph path.</span>
        <span class="n">new_part_meta</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;part-</span><span class="si">{</span><span class="n">part_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span>
            <span class="s2">&quot;part_graph_graphbolt&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">csc_graph_path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">part_config</span><span class="p">))</span>

    <span class="c1"># Save dtype info into partition config.</span>
    <span class="c1"># [TODO][Rui] Always use int64_t for node/edge IDs in GraphBolt. See more</span>
    <span class="c1"># details in #7175.</span>
    <span class="n">new_part_meta</span><span class="p">[</span><span class="s2">&quot;node_map_dtype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;int64&quot;</span>
    <span class="n">new_part_meta</span><span class="p">[</span><span class="s2">&quot;edge_map_dtype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;int64&quot;</span>

    <span class="n">_dump_part_config</span><span class="p">(</span><span class="n">part_config</span><span class="p">,</span> <span class="n">new_part_meta</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converted partitions to GraphBolt format into </span><span class="si">{</span><span class="n">part_config</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, DGL Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>